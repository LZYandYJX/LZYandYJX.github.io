<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>内存映射文件</title>
    <link href="/2023/05/15/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/"/>
    <url>/2023/05/15/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h1><h2 id="传统的文件访问方式"><a href="#传统的文件访问方式" class="headerlink" title="传统的文件访问方式"></a>传统的文件访问方式</h2><p><img src="/2023/05/15/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/2023-05-15-20-46-42.png"></p><h2 id="内存映射文件-1"><a href="#内存映射文件-1" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p> <img src="/2023/05/15/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/2023-05-15-20-47-12.png"><br><img src="/2023/05/15/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/2023-05-15-20-47-28.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/15/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/2023-05-15-20-47-48.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>虚拟内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面分配策略</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h1><h2 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h2><p><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2023-05-15-20-39-17.png"><br><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2023-05-15-20-40-20.png"></p><h2 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h2><p><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2023-05-15-20-40-44.png"></p><h2 id="何处调入页面"><a href="#何处调入页面" class="headerlink" title="何处调入页面"></a>何处调入页面</h2><ol><li>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，<br>需将进程相关的数据从文件区复制到对换区。<br><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2023-05-15-20-41-35.png"></li><li>系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需<br>要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。<br><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2023-05-15-20-42-00.png"></li><li>UNIX 方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换<br>区，下次需要时从对换区调入。<br><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2023-05-15-20-42-33.png"></li></ol><h2 id="抖动-颠簸-现象"><a href="#抖动-颠簸-现象" class="headerlink" title="抖动(颠簸)现象"></a>抖动(颠簸)现象</h2><p><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2023-05-15-20-43-02.png"></p><h2 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h2><p><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2023-05-15-20-43-43.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/2023-05-15-20-44-06.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>虚拟内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面置换算法</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/2023-05-15-20-11-54.png"></p><h2 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a>最佳置换算法(OPT)</h2><ol><li>最佳置换算法（Optimal Page Replacement Algorithm）是一种理论上的页面置换算法，它通过选择以后不再使用或者在最长时间内不再被访问的页面进行置换，从而达到最低的缺页率1。然而，由于未来是无法预测的，所以这种算法是理想化的。<br><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/2023-05-15-20-13-17.png"></li></ol><h2 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a>先进先出置换算法(FIFO)</h2><ol><li>先进先出页面置换算法（First In First Out，FIFO）是一种简单的页面置换算法，它通过选择最早进入内存的页面进行置换，从而达到页面置换的目的1。这和我们现实生活中的排队方式很相似，先进队伍的人会先买到票，然后先从队伍中离开。如果使用FIFO算法作为页面置换算法，缓存空间大小是三个页面时，一次进入Page1, Page2, Page3。当Page4要进入缓存时，操作系统将会把Page1清除出缓存，将Page4加入至缓存中。如果再有Page5要进入缓存时，操作系统会将Page2清除出缓存空间，以此类推<br><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/2023-05-15-20-16-09.png"><br><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/2023-05-15-20-16-19.png"></li></ol><h2 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h2><ol><li>最近最久未使用算法（LRU，Least Recently Used）是一种页面置换算法。它的基本思想是根据页面调入内存后的使用情况进行决策，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问一来所经历的时间T，当需要淘汰一个页面时，选择现有页面中T值最大的，即最近最久未使用的页面予以淘汰<br><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/2023-05-15-20-18-43.png"></li></ol><h2 id="时钟置换算法-CLOCK"><a href="#时钟置换算法-CLOCK" class="headerlink" title="时钟置换算法(CLOCK)"></a>时钟置换算法(CLOCK)</h2><ol><li>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法（NRU，Not Recently Used）<br><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/2023-05-15-20-20-52.png"></li></ol><h2 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h2><p><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/2023-05-15-20-22-38.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/2023-05-15-20-22-56.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>虚拟内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>请求分页管理方式</title>
    <link href="/2023/05/15/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/05/15/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h1><p><img src="/2023/05/15/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-19-53-05.png"></p><h2 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h2><p><img src="/2023/05/15/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-19-53-35.png"></p><h2 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h2><p><img src="/2023/05/15/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-19-54-26.png"><br><img src="/2023/05/15/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-19-54-46.png"></p><h2 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h2><p><img src="/2023/05/15/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-19-55-06.png"><br><img src="/2023/05/15/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-19-55-14.png"><br><img src="/2023/05/15/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-19-55-22.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/15/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-19-55-37.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>虚拟内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟内存的基本概念</title>
    <link href="/2023/05/15/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/05/15/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h1><h2 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h2><p><img src="/2023/05/15/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-15-19-32-33.png"></p><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p><img src="/2023/05/15/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-15-19-32-52.png"></p><h2 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h2><p><img src="/2023/05/15/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-15-19-33-23.png"><br><img src="/2023/05/15/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-15-19-33-32.png"></p><h2 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h2><p><img src="/2023/05/15/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-15-19-33-54.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>虚拟内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>习题总结</title>
    <link href="/2023/05/15/%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2023/05/15/%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="习题总结"><a href="#习题总结" class="headerlink" title="习题总结"></a>习题总结</h1><ol><li>编址空间的大小取决于硬件的访存能力，一般由地址总线宽度决定。</li><li>虚拟内存的管理由相关的硬件和软件支持，由请求分页页表机制、缺页中断机构、地址变换机构。</li><li>实现虚拟内存的管理需要一定的硬件支持，包括一定容量的内存和外存，页表机制（或段表机制）作为主要的数据结构，中断机构，当用户程序要访问的部分尚未调入内存，则产生中断，以及地址变换机构，用于逻辑地址到物理地址的变换。虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</li><li>段页式存储管理中，地址映射表是–&gt;每个进程一张段表，每个段一张页表。</li><li>内存保护是内存管理的nn一部分，是操作系统的任务，但是处于安全性和效率考虑，必须由硬件实现，所以需要操作系统和硬件机构的合作来实现。</li><li>覆盖技术是早期在单一连续存储管理中使用的扩大存储容量的一种技术，它同样可用于固定分区分配的存储管理。</li><li>静态装入是指在编程阶段就把物理地址计算好。 </li><li>可重定位是指在装入时把逻辑地址转换成物理地址，但装入后不能改变</li><li>动态重定位是指在执行时再决定装入的地址并装入，装入后有可能会换出，所以同一个模块在内存中的物理地址是可能改变的。 </li><li>动态重定位是指在作业运行过程中执行到一条访存指令时，再把逻辑地址转换为主存中的物理地址，实际中是通过硬件地址转换机制实现的。</li><li>固定分区方式中，作业装入后位置不在改变，可以采用静态重定位</li><li>在可变分区管理中，回收空闲区时采用拼接技术对空闲区进行合并。</li><li>分页式存储管理有内部碎片，分段式存储管理有外部碎片，固定分区存储管理方式有内部碎片，段页式存储管理方式有内部碎片。</li><li>多进程的执行通过内存保护实现互不干扰，如页式管理中有页地址越界保护，段式管理中有段地址越界保护。</li><li>内存分页管理是在硬件和操作系统层面实现的，对用户、编译系统、连接装配程序等上层是不可见的。</li><li>页表的功能由一组专门的存储器实现，其始址放在页表基址寄存器(PTBR)中。这样才能满足在地址变换时能够较快地完成逻辑地址和物理地址之间的转换。</li><li>对重定位存储管理方式，应在整个系统中设置一个重定位寄存器。</li><li>分段是指在用户编程时，将程序按照逻辑划分为几个逻辑阶段。</li><li>分段存储管理有利于程序的动态链接。动态链接是指在程序运行时，有需要才去调用某个动态链接库1。它的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</li><li>可重入程序主要是通过共享来使用同一块存储空间的，或通过动态链接的方式将所需的程序段映射到相关进程中去，其最大的优点是减少了对程序段的调入&#x2F;调出，因此减少了对换数。</li><li>内存管理是为了提高内存的利用率，引入覆盖和交换技术，即在较小的内存空间中采用重复使用的方法来节省存储空间，但它付出的代价是需要消耗更多的处理器时间，因此实际上是一种以时间换空间的技术。</li><li>引入段式存储器管理方式，主要是为了更好地满足用户的下列要求：方便编程、分段共享、分段保护、动态链接和动态增长。</li><li>存储管理的目的有两个：一个是方便用户，二是提高内存利用率。</li><li>对主存储器的访问，以字节或字为单位。</li><li>把作业空间中使用的逻辑地址变为内存中的物理地址称为重定位。</li><li>单用户连续分配管理方式只适用于单用户、单任务的操作系统，不适用于多道程序设计。</li><li>在分页存储管理中，逻辑地址分配是按页为单位进行分配的，而主存的分配即物理地址分配是以内存块为单位分配的。</li><li>操作系统采用分页存储管理方式，要求每个进程拥有一张页表，且进程的页表驻留在内存中。</li><li>在分段存储管理方式中，以段为单位进行分配，每段是一个连续存储区，每段不一定等长，段与段之间可连续，可不连续。</li><li>段页式存储管理兼有页式管理和段式管理的优点，采用分段方法来分配和管理用户地址空间，采用分页方式来管理物理存储空间。但它的开销要比段式和页式管理的开销大。</li><li><font color = red >只要是固定的分配就会产生内部碎片，其余的都会产生外部碎片。</font>若固定和不固定同时存在（例如段页式），则仍视为固定。分段虚拟存储管理：每段的长度都不一样（对应不固定），所以会产生外部碎片。分页虚拟存储管理：每页的长度都一样（对应固定），所以会产生内部碎片。 段页式分区管理：既有固定，又有不固定，以固定为主，所以会有内部碎片。固定式分区管理： 很明显固定，会产生内部碎片。</li><li>分区分配内存管理方式是把主存储器中的用户区作为一个连续区或分成若干个连续区进行管理，每个连续区中可装入一个作业。具体可分为固定分区和可变分区两种方式。</li><li>固定分区存储管理是把主存中可分配的用户区域预先划分成若干个连续的分区，每个连续的分区中只能装入一个作业。</li><li>而可变分区存储管理又称为动态分区分配，它不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。</li><li>分段存储管理的逻辑地址分为段号和位移量两部分，段内位移的最大值就是最大段长。</li><li>编译后的程序需要经过链接才能装载，而链接后形成的目标程序中的地址也就是逻辑地址。</li><li>多级页表不仅不会加快地址的变换速度，还会因为增加更多的查表过程，使地址变换速度减慢；也不会减少缺页中断的次数，反而如果访问过程中多级的页表都不在内存中，会大大增加缺页的次数，并不会减少页表项所占的字节数，而多级页表能够减少页表所占的连续内存空间，即当页表太大时，将页表再分级，把每张页表控制在一页之内，减少页表所占的连续内存空间</li><li>在多级页表中，页表基址寄存器存放的是顶级页表的起始物理地址，故存放的是一级页表的起始物理地址。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>段页式管理方式</title>
    <link href="/2023/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h1><h2 id="分段、分页的优缺点分析"><a href="#分段、分页的优缺点分析" class="headerlink" title="分段、分页的优缺点分析"></a>分段、分页的优缺点分析</h2><p><img src="/2023/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-44-07.png"></p><h2 id="分段-分页-x3D-段页式管理"><a href="#分段-分页-x3D-段页式管理" class="headerlink" title="分段+分页 &#x3D; 段页式管理"></a>分段+分页 &#x3D; 段页式管理</h2><p><img src="/2023/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-44-35.png"></p><h2 id="段页式管理的逻辑地址结构"><a href="#段页式管理的逻辑地址结构" class="headerlink" title="段页式管理的逻辑地址结构"></a>段页式管理的逻辑地址结构</h2><p><img src="/2023/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-45-00.png"></p><h2 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h2><p><img src="/2023/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-45-20.png"><br><img src="/2023/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-45-32.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-45-45.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本分段存储管理方式</title>
    <link href="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h1><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p><img src="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-31-56.png"><br><img src="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-32-20.png"></p><h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><p><img src="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-32-42.png"></p><h2 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h2><p><img src="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-33-14.png"><br><img src="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-33-29.png"></p><h2 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a>分段、分页管理的对比</h2><p><img src="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-33-56.png"><br><img src="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-34-17.png"><br><img src="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-34-25.png"><br><img src="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-34-33.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/15/%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-15-16-34-49.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>两级页表</title>
    <link href="/2023/05/14/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/"/>
    <url>/2023/05/14/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h1><h2 id="单级页表存在的问题"><a href="#单级页表存在的问题" class="headerlink" title="单级页表存在的问题"></a>单级页表存在的问题</h2><p><img src="/2023/05/14/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/2023-05-15-17-24-00.png"></p><ol><li>根据程序局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存。</li></ol><h2 id="如何解决单级页表的问题"><a href="#如何解决单级页表的问题" class="headerlink" title="如何解决单级页表的问题"></a>如何解决单级页表的问题</h2><ol><li>把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表</li></ol><h2 id="两级页表的原理、地址结构"><a href="#两级页表的原理、地址结构" class="headerlink" title="两级页表的原理、地址结构"></a>两级页表的原理、地址结构</h2><p><img src="/2023/05/14/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/2023-05-15-16-04-10.png"><br><img src="/2023/05/14/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/2023-05-15-16-04-29.png"></p><h2 id="如何实现地址变换"><a href="#如何实现地址变换" class="headerlink" title="如何实现地址变换"></a>如何实现地址变换</h2><p><img src="/2023/05/14/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/2023-05-15-16-04-54.png"></p><h2 id="需要注意的几个细节"><a href="#需要注意的几个细节" class="headerlink" title="需要注意的几个细节"></a>需要注意的几个细节</h2><p><img src="/2023/05/14/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/2023-05-15-16-05-53.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/14/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/2023-05-15-16-06-08.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>具有快表的地址变换机构</title>
    <link href="/2023/05/14/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84/"/>
    <url>/2023/05/14/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h1><h2 id="什么是快表"><a href="#什么是快表" class="headerlink" title="什么是快表"></a>什么是快表</h2><p>快表，又称联想寄存器（TLB， translation lookaside buffer ），是一种访问速度比内存快很多的高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。<br><img src="/2023/05/14/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84/2023-05-14-20-03-55.png"></p><h2 id="引入快表过后的地址变换过程"><a href="#引入快表过后的地址变换过程" class="headerlink" title="引入快表过后的地址变换过程"></a>引入快表过后的地址变换过程</h2><p><img src="/2023/05/14/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84/2023-05-14-20-04-22.png"><br><img src="/2023/05/14/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84/2023-05-14-20-04-34.png"></p><h2 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h2><p><img src="/2023/05/14/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84/2023-05-14-20-04-53.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/14/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84/2023-05-14-20-05-05.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本地址变换机构</title>
    <link href="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84/"/>
    <url>/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h1><h2 id="基本地址变换机构原理"><a href="#基本地址变换机构原理" class="headerlink" title="基本地址变换机构原理"></a>基本地址变换机构原理</h2><p><img src="/2023-05-14-19-42-46.png"><br><img src="/2023-05-14-19-43-05.png"><br><img src="/2023-05-14-19-43-34.png"><br><img src="/2023-05-14-19-43-51.png"></p><h2 id="对页表项进一步探讨"><a href="#对页表项进一步探讨" class="headerlink" title="对页表项进一步探讨"></a>对页表项进一步探讨</h2><p><img src="/2023-05-14-19-44-39.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023-05-14-19-44-56.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本分页存储管理的基本概念</title>
    <link href="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="基本分页存储管理的基本概念"><a href="#基本分页存储管理的基本概念" class="headerlink" title="基本分页存储管理的基本概念"></a>基本分页存储管理的基本概念</h1><h2 id="什么是“地址空间”"><a href="#什么是“地址空间”" class="headerlink" title="什么是“地址空间”"></a>什么是“地址空间”</h2><p><img src="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-14-19-22-20.png"></p><h2 id="什么是分页存储"><a href="#什么是分页存储" class="headerlink" title="什么是分页存储"></a>什么是分页存储</h2><p><img src="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-14-19-22-54.png"></p><h2 id="重要的数据结构–页表"><a href="#重要的数据结构–页表" class="headerlink" title="重要的数据结构–页表"></a>重要的数据结构–页表</h2><p><img src="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-14-19-23-23.png"></p><h2 id="每个页表占多少个字节"><a href="#每个页表占多少个字节" class="headerlink" title="每个页表占多少个字节"></a>每个页表占多少个字节</h2><p><img src="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-14-19-23-52.png"></p><h2 id="如何实现地址的转换"><a href="#如何实现地址的转换" class="headerlink" title="如何实现地址的转换"></a>如何实现地址的转换</h2><p><img src="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-14-19-24-29.png"></p><h2 id="如何确定一个逻辑地址对应的页号、页内偏移量"><a href="#如何确定一个逻辑地址对应的页号、页内偏移量" class="headerlink" title="如何确定一个逻辑地址对应的页号、页内偏移量"></a>如何确定一个逻辑地址对应的页号、页内偏移量</h2><p><img src="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-14-19-25-17.png"></p><h2 id="为何页面大小要取2的整数次幂"><a href="#为何页面大小要取2的整数次幂" class="headerlink" title="为何页面大小要取2的整数次幂"></a>为何页面大小要取2的整数次幂</h2><p><img src="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-14-19-26-02.png"></p><h2 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h2><p><img src="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-14-19-26-22.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/14/%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2023-05-14-19-26-38.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态分区分配算法</title>
    <link href="/2023/05/14/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <url>/2023/05/14/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h1><h2 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h2><ol><li>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li><li>如何实现：<font color = red>空闲分区以地址递增的次序排列。</font>每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区<br><img src="/2023/05/14/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/2023-05-14-19-00-23.png"></li></ol><h2 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h2><ol><li>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。</li><li>如何实现：<font color = red>空闲分区按容量递增次序链接。</font>每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区<br><img src="/2023/05/14/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/2023-05-14-19-00-57.png"></li></ol><h2 id="最坏适应算法–又称-最大适应算法（Largest-Fit）"><a href="#最坏适应算法–又称-最大适应算法（Largest-Fit）" class="headerlink" title="最坏适应算法–又称 最大适应算法（Largest Fit）"></a>最坏适应算法–又称 最大适应算法（Largest Fit）</h2><ol><li>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li><li>如何实现：<font color = red>空闲分区按容量递减次序链接。</font>每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区<br><img src="/2023/05/14/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/2023-05-14-19-01-46.png"></li></ol><h2 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h2><ol><li>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</li><li>如何实现：<font color = red>空闲分区以地址递增的顺序排列（可排成一个循环链表）。</font>每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区<br><img src="/2023/05/14/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/2023-05-14-19-03-32.png"></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/14/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/2023-05-14-19-03-53.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>连续分配管理方式</title>
    <link href="/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h1><h2 id="单一连续分配方式"><a href="#单一连续分配方式" class="headerlink" title="单一连续分配方式"></a>单一连续分配方式</h2><p><img src="/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-14-17-45-15.png"></p><h2 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h2><p><img src="/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-14-17-45-52.png"><br><img src="/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-14-17-47-44.png"></p><h2 id="动态分区算法"><a href="#动态分区算法" class="headerlink" title="动态分区算法"></a>动态分区算法</h2><ol><li>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）</li><li>需要考虑的问题：<ol><li>系统要用什么样的数据结构记录内存的使用情况？</li><li>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</li><li>如何进行分区的分配与回收操作？<br><img src="/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-14-17-52-47.png"><br><img src="/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-14-17-53-05.png"><br><img src="/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-14-17-53-43.png"><br><img src="/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-14-17-53-55.png"><br><img src="/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-14-17-54-55.png"></li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/14/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/2023-05-14-17-55-05.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>覆盖与交换</title>
    <link href="/2023/05/14/%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/"/>
    <url>/2023/05/14/%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h1><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><ol><li>覆盖的思想：<br>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</li><li>覆盖的特点:<br>打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，此外，内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存。覆盖技术对用户和程序员不透明。</li><li>在存储管理方案中，单一连续区存储管理可采用覆盖技术。覆盖技术的实现是把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构使那些不会同时运行的程序段共享同一块内存区域。<br><img src="/2023/05/14/%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/2023-05-14-16-39-53.png"><br><img src="/2023/05/14/%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/2023-05-14-16-40-04.png"></li></ol><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><ol><li>交换的思想：<br>把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又称换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称换入。</li><li>需要注意的问题：<ol><li>交换需要备份存储，通常是磁盘。它必须足够大，并提供对这些内存映像的直接访问。</li><li>为了有效使用CPU,需要使每个进程的执行时间比交换时间长。</li><li>若换出进程，则必须确保该进程完全处于空闲状态</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快。</li><li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。</li><li>普通的交换使用不多，但交换策略的某些变体在许多系统（如UNIX）中仍发挥作用。</li></ol></li><li>操作系统交换技术是一种时间换空间的策略。当内存空间紧张时，系统会将内存中某些进程暂时换出到外存，以腾出内存空间供其他进程使用。这个过程需要一定的时间来完成，但可以有效地扩展可用的内存空间。<br><img src="/2023/05/14/%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/2023-05-14-16-40-23.png"><br><img src="/2023/05/14/%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/2023-05-14-16-40-30.png"><br><img src="/2023/05/14/%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/2023-05-14-16-40-41.png"></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/14/%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2/2023-05-14-16-41-12.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存管理的概念</title>
    <link href="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h1><h2 id="内存空间的分配和回收"><a href="#内存空间的分配和回收" class="headerlink" title="内存空间的分配和回收"></a>内存空间的分配和回收</h2><ol><li>由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</li></ol><h2 id="内存空间的扩展"><a href="#内存空间的扩展" class="headerlink" title="内存空间的扩展"></a>内存空间的扩展</h2><ol><li>利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</li></ol><h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><ol><li>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。<br><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/2023-05-14-16-26-36.png"></li></ol><h2 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h2><ol><li>可采取两种方法：<ol><li>在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li><li>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。<br><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/2023-05-14-16-28-00.png"><br><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/2023-05-14-16-28-15.png"></li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/2023-05-14-16-28-31.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存的基础知识</title>
    <link href="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h1><h2 id="什么是内存？有何作用？"><a href="#什么是内存？有何作用？" class="headerlink" title="什么是内存？有何作用？"></a>什么是内存？有何作用？</h2><ol><li>内存可存放数据。程序执行前需要先存放到内存中才能被CPU处理–缓和CPU与硬盘之间的速度矛盾。</li></ol><h2 id="几个常用的数量单位"><a href="#几个常用的数量单位" class="headerlink" title="几个常用的数量单位"></a>几个常用的数量单位</h2><p><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-13-26-19.png"></p><h2 id="指令的工作原理"><a href="#指令的工作原理" class="headerlink" title="指令的工作原理"></a>指令的工作原理</h2><p><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-13-34-53.png"><br><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-13-35-04.png"><br><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-13-35-16.png"></p><h2 id="装入的三种方式–绝对装入"><a href="#装入的三种方式–绝对装入" class="headerlink" title="装入的三种方式–绝对装入"></a>装入的三种方式–绝对装入</h2><p><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-16-01-21.png"></p><h2 id="装入的三种方式–可重定位装入"><a href="#装入的三种方式–可重定位装入" class="headerlink" title="装入的三种方式–可重定位装入"></a>装入的三种方式–可重定位装入</h2><p><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-16-02-00.png"></p><h2 id="装入的三种方式–动态运行时装入"><a href="#装入的三种方式–动态运行时装入" class="headerlink" title="装入的三种方式–动态运行时装入"></a>装入的三种方式–动态运行时装入</h2><p><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-16-02-41.png"></p><h2 id="装入的三种方式–动态重定位"><a href="#装入的三种方式–动态重定位" class="headerlink" title="装入的三种方式–动态重定位"></a>装入的三种方式–动态重定位</h2><p><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-16-03-18.png"></p><h2 id="从写程序到程序运行"><a href="#从写程序到程序运行" class="headerlink" title="从写程序到程序运行"></a>从写程序到程序运行</h2><p><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-16-08-41.png"></p><h2 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h2><p><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-16-09-20.png"><br><img src="/2023/05/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/2023-05-14-16-09-56.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>支持程序浮动的地址转换机制是动态重定位。动态重定位是一种地址转换机制，它允许程序在内存中浮动，即程序可以被加载到内存的任意位置。在程序执行时，动态重定位器会将程序中的逻辑地址转换为物理地址，以便程序能够正确访问内存。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第三章</category>
      
      <category>内存管理概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>死锁</title>
    <link href="/2023/05/13/%E6%AD%BB%E9%94%81/"/>
    <url>/2023/05/13/%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><h3 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-10-46-29.png"></p><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-10-46-53.png"></p><h3 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-10-47-19.png"></p><h3 id="死锁处理的策略"><a href="#死锁处理的策略" class="headerlink" title="死锁处理的策略"></a>死锁处理的策略</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-10-47-41.png"><br><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-10-47-51.png"></p><h2 id="死锁的处理策略–预防死锁"><a href="#死锁的处理策略–预防死锁" class="headerlink" title="死锁的处理策略–预防死锁"></a>死锁的处理策略–预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-10-58-15.png"></p><h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-10-58-44.png"></p><h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-10-59-08.png"></p><h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-10-59-30.png"><br><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-10-59-41.png"></p><h2 id="死锁的处理策略–避免死锁-银行家算法"><a href="#死锁的处理策略–避免死锁-银行家算法" class="headerlink" title="死锁的处理策略–避免死锁(银行家算法)"></a>死锁的处理策略–避免死锁(银行家算法)</h2><h3 id="安全序列、不安全序列、死锁的联系"><a href="#安全序列、不安全序列、死锁的联系" class="headerlink" title="安全序列、不安全序列、死锁的联系"></a>安全序列、不安全序列、死锁的联系</h3><ol><li>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全状态可以有多个。</li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</li><li>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)。</li><li>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</li></ol><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-11-14-43.png"><br><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-11-14-53.png"><br><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-11-15-03.png"><br><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-11-15-41.png"></p><h2 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h2><h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-11-21-29.png"><br><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-11-21-48.png"><br><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-11-21-57.png"><br><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-11-22-06.png"></p><h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-11-22-32.png"><br><img src="/2023/05/13/%E6%AD%BB%E9%94%81/2023-05-14-11-22-45.png"></p><h2 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h2><ol><li>死锁避免是指在资源动态分配过程中用某些算法加以限制，防止系统进入不安全状态从而避免死锁的发生。</li><li>资源有序分配策略可以限制循环等待条件的发生。</li><li>解除死锁的方法有：<ol><li>剥夺资源法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。</li><li>撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源</li></ol></li><li>资源有序分配算法为死锁预防策略。</li><li>多道程序技术要求进程间能实现并发，需要实现进程调度以保证CPU的工作效率，而并发性的实现需要中断功能的支持。</li><li>进程指向资源的有向边称为申请边，资源指向进程的有向边称为分配边。矩形框表示资源，其中的圆点表示资源的数目。圆圈结点表示进程。</li><li>死锁的四个必要条件中，无法破坏的是资源互斥，也就是说，在任何时候，每个资源只能被一个进程占用。由于资源的本质是稀缺的，资源只能供一个进程独占，因此互斥是无法破坏的。</li><li>死锁定理是用于检测死锁的方法。</li><li>银行家算法是避免死锁的算法，用于计算动态资源分配的安全性以避免系统进入死锁状态，不能用于判断系统是否处于死锁。</li><li>在死锁的检测和解除中，系统为进程分配资源时不采取任何措施，但提供死锁的检测和解除手段。</li><li>在多进程的并发系统中，肯定不会因竞争CPU而产生死锁。死锁通常发生在多个进程竞争有限的非抢占资源时，而CPU是一种抢占资源，可以从一个进程中抢占并分配给另一个进程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>同步与互斥</title>
    <link href="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/"/>
    <url>/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h2 id="进程同步、进程互斥"><a href="#进程同步、进程互斥" class="headerlink" title="进程同步、进程互斥"></a>进程同步、进程互斥</h2><h3 id="什么是进程同步"><a href="#什么是进程同步" class="headerlink" title="什么是进程同步"></a>什么是进程同步</h3><ol><li>进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</li><li>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</li></ol><h3 id="什么是进程互斥"><a href="#什么是进程互斥" class="headerlink" title="什么是进程互斥"></a>什么是进程互斥</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-18-28-45.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-18-30-54.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-18-31-45.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-18-32-27.png"></p><h2 id="进程互斥的软件实现方式"><a href="#进程互斥的软件实现方式" class="headerlink" title="进程互斥的软件实现方式"></a>进程互斥的软件实现方式</h2><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-18-38-04.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-18-41-35.png"></p><h3 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-18-41-58.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-18-42-15.png"></p><h3 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-18-45-51.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-18-46-01.png"></p><h3 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-08-11.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-08-34.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-08-51.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-09-02.png"></p><h2 id="进程互斥的硬件实现方式"><a href="#进程互斥的硬件实现方式" class="headerlink" title="进程互斥的硬件实现方式"></a>进程互斥的硬件实现方式</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-23-40.png"></p><h3 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-27-03.png"></p><h3 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-29-34.png"></p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-33-16.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-36-42.png"></p><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-39-03.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-43-37.png"></p><h3 id="信号量机制-—-gt-整型信号量"><a href="#信号量机制-—-gt-整型信号量" class="headerlink" title="信号量机制 —&gt; 整型信号量"></a>信号量机制 —&gt; 整型信号量</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-48-11.png"></p><h3 id="信号量机制-—-gt-记录型信号量"><a href="#信号量机制-—-gt-记录型信号量" class="headerlink" title="信号量机制 —&gt; 记录型信号量"></a>信号量机制 —&gt; 记录型信号量</h3><ol><li>记录型信号量除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构</li><li>wait操作，S.value-表示进程请求一个该类资源，当S.value &lt;0时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入该类资源的等待队列S.L,可见该机制遵循了 “让权等待”的准则。</li><li>signal操作，表示进程释放一个资源,使系统中可供分配的该类资源数增1,因此有S.value ++。若加1后仍是S.valueWO,则表示在S.L中仍有等待该资源的进程被阻塞，因此还应调用wakeup原语，将S.L中的第一个等待进程唤醒。<br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-53-39.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-56-58.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-19-57-10.png"></li></ol><h2 id="用信号量机制实现进程互斥、同步、前驱关系"><a href="#用信号量机制实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量机制实现进程互斥、同步、前驱关系"></a>用信号量机制实现进程互斥、同步、前驱关系</h2><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-01-02.png"></p><h3 id="信号量机制实现进程互斥"><a href="#信号量机制实现进程互斥" class="headerlink" title="信号量机制实现进程互斥"></a>信号量机制实现进程互斥</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-03-49.png"></p><h3 id="信号量机制实现进程同步"><a href="#信号量机制实现进程同步" class="headerlink" title="信号量机制实现进程同步"></a>信号量机制实现进程同步</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-05-26.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-05-37.png"></p><h3 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h3><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-05-47.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-05-56.png"> </p><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-23-58.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-24-07.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-24-27.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-24-40.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-24-50.png"></p><ol><li>实现互斥的P操作一定要在实现同步的P操作之后</li><li>V操作不会导致进程阻塞，因此两个V操作顺序可以交换<br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-24-58.png"></li></ol><h2 id="多生产者–多消费者"><a href="#多生产者–多消费者" class="headerlink" title="多生产者–多消费者"></a>多生产者–多消费者</h2><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-48-30.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-48-43.png"></p><ol><li>问题 –&gt; 可不可以不用互斥信号量</li><li>结论 –&gt; 即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。</li><li>原因 –&gt; 本题种的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。</li><li>如果盘子的个数为2<br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-53-26.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-53-34.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-20-53-44.png"></li></ol><h2 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h2><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-03-58.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-04-07.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-04-16.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-04-24.png"></p><h2 id="读者–写者问题"><a href="#读者–写者问题" class="headerlink" title="读者–写者问题"></a>读者–写者问题</h2><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-18-21.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-18-31.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-18-41.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-18-52.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-19-02.png"></p><h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-29-15.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-29-30.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-29-51.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-30-05.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-30-13.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-30-29.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-30-38.png"></p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-31-09.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-31-17.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-31-30.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-31-52.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-31-59.png"><br><img src="/2023/05/13/%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2023-05-13-21-32-09.png"></p><h2 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h2><ol><li>多个进程可以共享系统中的资源，一次仅允许一个进程使用的资源称为临界资源。访问临界资源的那段代码称为临界区。</li><li>所谓临界区，并不是指临界资源，如共享的数据、代码或硬件设备等，而是指访问临界资源的那段代码程序，如P&#x2F;V操作、加减锁等。</li><li>临界资源是互斥共享资源，非共享数据不属于临界资源。打印机、共享变量和共享缓冲区都只允许一次供一个进程使用。</li><li>P、V操作是一种低级的进程通信原语，它是不能被中断的</li><li>管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程并改变管程中的数据。</li><li>共享程序段可能同时被多个进程使用，所以必须可重入编码，否则无法实现共享的功能</li><li>管程由局限于管程的共享变量说明、对管程内的数据结构进行操作的一组过程及对局限于管程的数据设置初始值的语句组成。</li><li>管程的signal操作与信号量机制中的V操作不同，信号量机制中的V操作一定会改变信号量的值S&#x3D;S+1。而管程中的signal操作是针对某个条件变量的，若不存在该条件而阻塞的进程，则signal不会产生任何影响。</li><li>PV操作是一种低级的进程通信原语，不是系统调用。</li><li>管程具有如下特性：①局部于管程的数据只能被局部于管程内的过程所访问。②一个进程只有通过调用管程内的过程才能进入管程访问共享数据。③每次仅允许一个进程在管程内执行某个内部过程。</li><li>信号量方法可以实现让权等待。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>处理机调度</title>
    <link href="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
    <url>/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h2 id="调度的概念、层次"><a href="#调度的概念、层次" class="headerlink" title="调度的概念、层次"></a>调度的概念、层次</h2><h3 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h3><ol><li>在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效的原则）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</li><li>处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</li></ol><h3 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h3><ol><li>一个作业从提交开始直到完成，往往要经历以下三级调度：<ol><li>高级调度(作业调度)<br>※ 按照一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。<br>※ 作业：一个具体的任务。<br>※ 用户向系统提交一个作业 $\approx$ 用户让操作系统启动一个程序(来处理一个具体任务)<br>※ 简而言之，作业调度就是内存与辅存之间的调度。每个作业只调入一次、调出一次。</li><li>中级调度(内存调度)<br>※ 引入中级调度的目的是提高内存利用率和系统吞吐量<br>※ 将那些暂时不能运行的进程调度至外存等待，此时进程的状态称为挂起态。当它们已具备运行条件且内存又稍有空闲时，由中间调度决定把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。<br>※ 中级调度实际上是存储器管理中的对换功能。</li><li>低级调度(进程调度&#x2F;处理机调度)<br>※ 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。<br>※ 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度\</li></ol></li></ol><h3 id="三级调度的联系"><a href="#三级调度的联系" class="headerlink" title="三级调度的联系"></a>三级调度的联系</h3><p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。</p><ol><li>作业调度为进程活动做准备，进程调度使进程正常活动起来。</li><li>中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li><li>作业调度次数少，中级调度次数略多，进程调度频率最高。</li><li>进程调度是最基本的，不可或缺。</li></ol><h3 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h3><p><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-19-59-24.png"></p><h3 id="三层调度的联系、对比"><a href="#三层调度的联系、对比" class="headerlink" title="三层调度的联系、对比"></a>三层调度的联系、对比</h3><p><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-20-00-33.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-20-03-18.png"> </p><h2 id="进程调度的时机切换与过程调度的方式"><a href="#进程调度的时机切换与过程调度的方式" class="headerlink" title="进程调度的时机切换与过程调度的方式"></a>进程调度的时机切换与过程调度的方式</h2><h3 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h3><p><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-20-49-40.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-20-55-14.png"></p><ol><li>现代操作系统中，不能进行进程的调度与切换的情况有以下几种：<ol><li>在处理中断的过程中。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。</li><li>进程在操作系统内核临界区中。进入临界区后，需要独占式地访问，理论上必须加锁， 以防止其他并行进程进入，在解锁前不应切换到其他进程，以加快临界区的释放。</li><li>其他需要完全屏蔽中断的原子操作过程中。如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</li></ol></li><li>进程切换往往在调度完成后立刻发生，它要求保存原进程当前断点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</li></ol><h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><p><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-21-05-30.png"></p><h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><p><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-21-47-57.png"></p><h2 id="调度器、闲逛进程"><a href="#调度器、闲逛进程" class="headerlink" title="调度器、闲逛进程"></a>调度器、闲逛进程</h2><ol><li>调度程序(调度器)<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-22-08-45.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-22-08-58.png"></li><li>用于调度和分派CPU的组件称为调度程序，它通常由三部分组成:<br>   ① 排队器。将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，排队器便将它插入到相应的就绪队列中。<br>   ②分派器。依据调度程序所选的进程，将其从就绪队列中取出，将CPU分配给新进程<br>   ③上下文切换器。在对处理机进行切换时，会发生两对上下文的切换操作：第一对，将当前进程的上下文保存到其PCB中，再装入分派程序的上下文，以便分派程序运行；第二对，移出分派程序的上下文，将新选进程的CPU现场信息装入处理机的各个相应寄存器。<br>   <img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-22-14-34.png"></li><li>闲逛进程<ol><li>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程</li><li>闲逛进程的特性：<br>※ 优先级最低<br>※ 可以是0地址指令，占一个完整的指令周期(指令周期末尾例行检查中断)<br>※ 能耗低</li></ol></li></ol><h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><p>处理机调度算法的性能评价标准：</p><ol><li>CUP利用率：CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU保持“忙”状态，使这一资源利用率最高。CPU利用率的计算方式如下：<br>$$ CPU利用率&#x3D;\frac{CPU有效工作时间}{CPU有效工作时间 + CPU空闲等待时间}$$<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-22-17-33.png"></li><li>系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间,因此会降低系统的吞吐量。而对于短作业，需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。<br>$$ 系统吞吐量&#x3D;\frac{总共完成了多少道作业}{总共花了多少时间}$$<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-12-22-18-51.png"></li><li>周转时间。指从作业提交到作业完成所经历的时间，是作业等待、在就绪队列中排队、 在处理机上运行及输入&#x2F;输出操作所花费时间的总和。周转时间的计算方法如下：</li></ol><center>周转时间=作业完成时间-作业提交时间\</center><p>平均周转时间是指多个作业周转时间的平均值：</p><center>平均周转时间=（作业1的周转时间+...+作业n的周转时间）/ n </center> <p>带权周转时间是指作业周转时间与作业实际运行时间的比值: </p><p> $$ 带权周转时间 &#x3D; \frac{作业周转时间}{作业实际运行时间}&#x3D;\frac{作业完成时间 – 作业提交时间}{作业实际运行的时间}$$</p><p>$$ 带权周转时间必然 \geq 1 $$</p><p>带权周转时间与周转时间都是越小越好</p><p>平均带权周转时间是指多个作业带权周转时间的平均值：</p><center>平均带权周转时间=（作业1的带权周转时间+•••+作业n的带权周转时间）/ n </center><ol start="4"><li>等待时间。<ol><li>指进程处于等处理机的时间之和，等待时间越长，用户满意度越低。</li><li>处理机调度算法实际上并不影响作业执行或输入&#x2F;输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法的优劣，常常只需简单地考察等待时间。</li><li>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。</li><li>对于作业来说，不仅考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</li><li>一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是不确定的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。</li></ol></li><li>响应时间。指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一。从用户角度来看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</li><li>设计调度程序，一方面要满足特定系统用户的要求（如某些实时和交互进程的快速响应要求），另一方面要考虑系统整体效率（如减少整个系统的进程平均周转时间），同时还要考虑调度算法的开销。<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-10-50-53.png"></li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>Tips：各种调度算法的学习思路</p><ol><li>算法思想</li><li>算法规则</li><li>这种调度算法是用于 作业调度 还是 进程调度？</li><li>抢占式？非抢占式？</li><li>优点和缺点</li><li>是否会导致饥饿</li></ol><h3 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a>先来先服务(FCFS)</h3><p><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-11-06-50.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-11-08-49.png"></p><h3 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a>短作业优先(SJF)</h3><ol><li>非抢占式的短作业优先调度算法—&gt; 又称为“最短剩余时间优先算法(SRTN)”<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-11-21-18.png"></li><li>抢占式的短作业优先算法<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-11-26-37.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-11-26-53.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-11-31-36.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-11-31-46.png"></li></ol><h3 id="高响应比优先-HRRN"><a href="#高响应比优先-HRRN" class="headerlink" title="高响应比优先(HRRN)"></a>高响应比优先(HRRN)</h3><ol><li>算法规则–&gt;在每次调度时先计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务.<br>$$ 响应比&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}$$<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-11-41-50.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-11-43-59.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-11-44-07.png"></li></ol><h3 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h3><ol><li>算法规则 –&gt; 按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li><li>时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到。</li><li>时间片大小为2时<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-12-00-06.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-12-00-58.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-12-01-06.png"></li><li>时间片大小为5时<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-12-01-29.png"></li><li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li><li>进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-12-54-40.png"></li></ol><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><ol><li>算法规则 —&gt; 每个作业&#x2F;进程有各自的优先级，调度时选择优先级最高的作业&#x2F;进程。</li><li>非抢占式<br>   <img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-12-59-57.png"></li><li>抢占式<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-13-00-15.png"></li><li>补充<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-13-01-40.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-13-01-51.png"></li></ol><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><ol><li>算法思想<ol><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片用于进程调度<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-13-06-51.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-13-07-00.png"><br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-13-07-10.png"></li></ol></li></ol><h3 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h3><p><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-13-14-04.png"></p><h2 id="各种算法总结"><a href="#各种算法总结" class="headerlink" title="各种算法总结"></a>各种算法总结</h2><p><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-13-15-41.png"></p><h2 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h2><ol><li>时间片轮转调度算法是为了多个用户能及时干预系统</li><li>CPU繁忙型作业是指该类作业需要占用很长的CPU时间，而很少请求I&#x2F;O操作，因此CPU繁忙型作业类似于长作业。</li><li>I&#x2F;O繁忙型作业是指作业执行时需频繁请求I&#x2F;O操作，即可能频繁放弃CPU，所以占用CPU的时间不会太长，一旦放弃CPU，则必须重新排队等待调度，故采用短作业优先合适。</li><li>进程(线程)调度的时机有：<ol><li>运行的进程(线程)运行完毕</li><li>运行的进程(线程)所需资源未准备好</li><li>运行的进程(线程)时间片用完</li><li>运行的进程(线程)自我阻塞</li><li>运行的进程(线程)出现错误</li></ol></li><li>时间片轮转算法是按固定的时间配额来运行的，时间一到，不管是否完成，当前进程必须撤下，调度新的进程，因此它是由时间配额决定的、是绝对可抢占的。而优先级算法和短进程优先算法都可分为抢占式和非抢占式。</li><li>作业是用户提交的，进程是系统自动生成的，除此之外，两者的区别是<ol><li>处理：作业通常指一组相互独立的任务或者程序，系统需要根据用户的要求分配资源，将其作为一个整体进行处理；而进程是系统进行资源调度和管理的基本单位，它是程序执行的实例，包括程序、数据和执行状态等元素。</li><li>生命周期：作业在系统中的生命周期包括提交、接受、调度、执行和完成等阶段；而进程的生命周期包括创建、就绪、运行、阻塞和完成等阶段，它有自己的程序计数器、内存空间和执行状态，可以被处理器调度执行。</li><li>独立性：一般情况下，作业是相互独立的，它们可以在不同的时间、不同的系统中进行处理；而进程之间相互依赖，它们需要共享资源、通信等协作操作，形成协同的执行方式。</li><li>资源占用：一个作业需要在执行前获得足够的系统资源，包括内存、CPU、IO等，通常比较耗费系统的资源；而一个进程可以比一个作业更轻量级，它只需获得少量的系统资源即可执行，因为它可以共享许多系统资源（如内存、存储器等）。</li><li>调度：作业调度主要是以作业为单位，对用户提交的作业进行优先级调度和资源分配等处理；而进程调度是以进程为单位，进行时间片轮转、优先级调度等操作，使所有进程能够得到公平的处理。</li><li>作业是以用户任务为单位，进程是以操作系统控制为单位<br><img src="/2023/05/12/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/2023-05-13-16-29-57.png"></li></ol></li><li>假设系统中所有进程同时到达，则使进程平均周转时间最短的算法是短进程优先调度算法。</li><li>高响应比优先算法在等待时间相同的情况下，作业执行时间越短，响应比越高，满足短任务优先。</li><li>一种既有利于短小作业又兼顾到长作业的作业调度算法是最高响应比优先算法。这种算法在等待时间相同时，作业执行的时间越短，响应比越高，满足短任务优先。同时，响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。</li><li>从系统的角度来考虑，希望进入“输入井”的批处理作业的等待时间尽可能小。这样可以提高系统的吞吐量和资源利用率。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><ol><li>在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程（Process）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性）。</li><li>为了使参与并发执行的每个程序（含数据）都能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块（Process Control Block, PCB）。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由<font color = red>程序段、相关数据段和PCB三部分构成了进程实体（又称进程映像）</font>。所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程的PCB。值得注意的是，<font color = red>进程映像是静态的，进程则是动态的。</font></li><li><font color = red>PCB是进程存在的唯一标志！</font></li><li>从不同的角度，进程可以有不同的定义，比较典型的定义有：<ol><li>进程是程序的一次执行过程。</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li></ol></li></ol><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><ol><li>进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。<ol><li>动态性。动态性是进程最基本的特征。</li><li>并发性。并发性是进程的重要特征，也是操作系统的重要特征。</li><li>独立性。凡未建立PCB的程序，都不能作为一个独立的单位参与运行。</li><li><font color = red>异步性。由于进程的相互制约，使得进程按各自独立的、不可预知的速度向前推进。</font></li></ol></li></ol><h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><ol><li>进程在其生命周期内，由于系统中各进程之间的相互制约及系统的运行环境的变化，使得进程的状态也在不断地发生变化。通常进程有以下5种状态，前3种是进程的基本状态。<ol><li>运行态。进程正在处理机上运行。在单处理机中，每个时刻只有一个进程处于运行态。</li><li>就绪态。<font color = red>进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。</font>系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li><li>阻塞态，又称等待态。进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入&#x2F;输出完成。即使处理机空闲，该进程也不能运行。系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。</li><li>创建态。进程正在被创建，尚未转到就绪态。创建进程需要多个步骤：首先申请一个空白PCB,并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后把该进程转入就绪态并插入就绪队列。但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。</li><li>终止态。进程正从系统中消失，可能是进程正常结束或其他原因退出运行。进程需要结束运行时，系统首先将该进程置为终止态，然后进一步处理资源释放和回收等工作。<br>※ 注意区别就绪态和等待态：<font color = red>就绪态是指进程仅缺少处理器，只要获得处理机资源就立即运行；而等待态是指进程需要其他资源（除了处理机）或等待某一事件</font>。之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说， 进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪态的；而其他资源（如外设）的使用和分配或某一事件的发生（如I&#x2F;O操作的完成）对应的时间相对来说很长，进程转换到等待态的次数也相对较少。这样来看，就绪态和等待态是进程生命周期中两个完全不同的状态，显然需要加以区分。</li></ol></li><li>3种基本状态之间的转换如下：<ol><li>就绪态–&gt;运行态：处于就绪态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪态转换为运行态。</li><li>运行态一就绪态：处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转换为就绪态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转换为就绪态，让更高优先级的进程执行。</li><li>运行态–&gt;阻塞态：进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I&#x2F;O操作的完成）时，它就从运行态转换为阻塞态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</li><li>阻塞态–&gt;就绪态：进程等待的事件到来时，如I&#x2F;O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态。</li><li>注意：<font color = red>一个进程从运行态变成阻塞态是主动的行为，而从阻塞态变成就绪态是被动的行为，需要其他相关进程的协助。</font><br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-21-34-11.png"></li></ol></li></ol><h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><p>进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。它由以下三部分<font color = red>(进程控制块、程序段和数据段)</font>组成，其中最核心的是进程控制块（PCB）。</p><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><ol><li>进程创建时，操作系统为它新建一个PCB,该结构之后常驻内存，任意时刻都可以存取，弃在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。</li><li><font color = red>进程执行时，系统通过其PCB 了解进程的现行状态信息，以便操作系统对其进行控制和管理；进程结束时，系统收回其PCB,该进程随之消亡。</font></li><li>在进程的整个生命期中，系统总是通过PCB对进程进行控制的，亦即系统唯有通过进程的PCB才能感知到该进程的存在。</li><li>PCB主要包括<font color = red>进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等</font>。各部分的主要说明如下：<br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-21-36-40.png"><ol><li>进程描述信息。进程标识符：标志各个进程，每个进程都有一个唯一的标识号。用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。</li><li>进程控制和管理信息。进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。进程优先级：描述进程抢占处理机的优先级，优先级高的进程可优先获得处理机。</li><li>资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入&#x2F;输出设备信息。</li><li>处理机相关信息，也称处理机的上下文，主要指处理机中各寄存器的值。当进程处于执行态时，处理机的许多信息都在寄存器中。当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能从断点继续执行。</li></ol></li><li>目前，常用的组织方式有链接方式和索引方式两种。链接方式将同一状态的PCB链接成一个队列， 不同状态对应不同的队列,也可把处于阻塞态的进程的PCB,根据其阻塞原因的不同，排成多个阻塞队列。索引方式将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB,不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</li></ol><h3 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h3><p>程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可被多个进程共享，即多个进程可以运行同一个程序。</p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ol><li>允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，通常也会同时撤销其所有的子进程。</li><li>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语）：<ol><li>为新进程分配一个唯一的进程标识号，并申请一个空白PCB （PCB是有限的）。若PCB申请失败，则创建失败。</li><li>为进程分配其运行所需的资源，如内存、文件、I&#x2F;O设备和CPU时间等（在PCB中体现）。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足（如内存），则并不是创建失败，而是处于创建态，等待内存资源。</li><li>初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li><li>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</li></ol></li></ol><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><ol><li>引起进程终止的事件主要有：①正常结束，表示进程的任务己完成并准备退出运行。②异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、 非法指令、特权指令错、运行超时、算术运算错、I&#x2F;O故障等。③外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</li><li>操作系统终止进程的过程如下（终止原语）<ol><li>根据被终止进程的标识符，检索出该进程的PCB,从中读出该进程的状态。</li><li>若被终止进程处于运行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</li><li>若该进程还有子孙进程，则应将其所有子孙进程终止。</li><li>将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。</li><li>将该PCB从所在队列（链表）中删除。</li></ol></li></ol><h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><ol><li>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、 新数据尚未到达或无新任务可做等，进程便通过调用阻塞原语（Block）,使自己由运行态变为阻塞态。可见，阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU）,才可能将其转为阻塞态。阻塞原语的执行过程如下：<ol><li>找到将要被阻塞进程的标识号对应的PCB</li><li>若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。</li><li>把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程。</li></ol></li><li>当被阻塞进程所期待的事件出现时，如它所期待的I&#x2F;O操作已完成或其所期待的数据已到达， 由有关进程（比如，释放该I&#x2F;O设备的进程，或提供数据的进程）调用唤醒原语（Wakeup）,将等待该事件的进程唤醒。唤醒原语的执行过程如下：<ol><li>在该事件的等待队列中找到相应进程的PCBo</li><li>将其从等待队列中移出，并置其状态为就绪态。</li><li>把该PCB插入就绪队列，等待调度程序调度。<br>※ <font color = red>注意：应当注意，Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。如果在某进程中调用了 Block原语，则必须在与之合作的或其他相关的进程中安排一条相应的Wakeup原语，以便唤醒阻塞进程；否则，阻塞进程将会因不能被唤醒而永久地处于阻塞状态。</font></li></ol></li></ol><h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><p>进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三类。</p><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><ol><li>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写&#x2F;读操作实现进程之间的信息交换。<br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-21-43-00.png"></li><li>在对共享空间进行写&#x2F;读操作时，需要使用同步互斥工具（如P操作、V操作），对共享空间的写&#x2F;读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式的共享则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读&#x2F;写指令完成。</li><li>注意：进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。</li></ol><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><ol><li>在消息传递系统中，进程间的数据交换以格式化的消息（Message）为单位。<font color = red>若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。</font>进程通过系统提供的发送消息和接收消息两个原语进行数据交换。这种方式隐藏了通信实现细节， 使通信过程对用户透明，简化了通信程序的设计，是当前应用最广泛的进程间通信机制。在微内核操作系统中，微内核与服务器之间的通信就采用了消息传递机制。由于该机制能很好地支持多处理机系统、分布式系统和计算机网络，因此也成为这些领域最主要的通信工具。<ol><li>直接通信方式。发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。<br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-21-44-56.png"></li><li>间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。 这种中间实体一般称为信箱。该通信方式广泛应用于计算机网络中。</li></ol></li></ol><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><ol><li>管道通信允许两个进程按生产者-消费者方式进行信，,生产者向管道的一端写，消费者从管道的另一端读。数据在管道中是先进先出的。只要管道非空，读进程就能从管道中读出数据，若数据被读空，则读进程阻塞，直到写进程往管道中写入新的数据，再将读进程唤醒。只要管道不满，写进程就能往管道中写入数据，若管道写满，则写进程阻塞，直到读进程读出数据，再将写进程唤醒。为了协调双方的通信，管道机制必须提供三方面的协调能力：互斥、同步和确定对方的存在。<br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-21-46-38.png"></li><li>在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下：<ol><li>限制管道的大小。管道文件是一个固定大小的缓冲区，在Linux中该缓冲区的大小为4KB,这使得它的大小不像普通文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write。调用写。</li><li>读进程也可能工作得比写进程快。当所有管道内的数据己被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了 read()调用返回文件结束的问题。</li></ol></li><li>管道只能由创建进程所访问，当父进程创建一个管道后，由于管道是一种特殊文件，子进程会继承父进程的打开文件，因此子进程也继承父进程的管道，并使用它来与父进程进进行通信。</li><li>注意：从管道读数据是一次性操作，数据一旦被读取， 就释放空间以便写更多数据。普通管道只允许单向通信，若要实现父子进程双向通信，则需要定义两个管道。</li></ol><h2 id="线程和多线程模型"><a href="#线程和多线程模型" class="headerlink" title="线程和多线程模型"></a>线程和多线程模型</h2><h3 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h3><ol><li><font color = red>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</font></li><li>一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</li></ol><h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><ol><li>调度。<font color = red>在传统的操作系统中，拥有资源和独立调度的基本单位都是进程</font>，每次调度都要进行上下文切换，开销较大。在引入线程的操作系统中，<font color = red>线程是独立调度的基本单位</font>， 而线程切换的代价远低于进程。<font color = red>在同一进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</font></li><li>并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且一个进程中的多个线程之间亦可并发执行，甚至不同进程中的线程也能并发执行，从而使操作系统具有更好的并发性，提高了系统资源的利用率和系统的吞吐量。</li><li>拥有资源。进程是系统中拥有资源的基本单位，而线程不拥有系统资源（仅有一点必不可少、能保证独立运行的资源），但线程可以访问其隶属进程的系统资源，这主要表现在属于同一进程的所有线程都具有相同的地址空间。要知道，若线程也是拥有资源的单位,则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义</li><li>独立性。每个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问。某进程中的线程对其他进程不可见。同一进程中的不同线程是为了提高并发性及进行相互之间的合作而创建的，它们共享进程的地址空间和资源。</li><li>系统开销。在创建或撤销进程时，系统都要为之分配或回收进程控制块PCB及其他资源,如内存空间、I&#x2F;O设备等。操作系统为此所付出的开销，明显大于创建或撤销线程时的开销。类似地，在进程切换时涉及进程上下文的切换，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。</li><li>支持多处理机系统。对于传统单线程进程，不管有多少处理机，进程只能运行在一个处理机上。对于多线程进程，可以将进程中的多个线程分配到多个处理机上执行。</li></ol><h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><ol><li>多线程操作系统中的进程已不再是一个基本的执行实体，但它仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。线程的主要属性如下<ol><li>线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。</li><li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。</li><li>同一进程中的各个线程共享该进程所拥有的资源。</li><li>线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中， 各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU,若各个CPU同时为一个进程内的各线程服务，则可缩短进程的处理时间。</li><li>一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</li></ol></li></ol><h3 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h3><ol><li>与进程一样，各线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。相应地，线程在运行时也具有下面三种基本状态。<ol><li>执行状态：线程己获得处理机而正在运行。</li><li>就绪状态：线程已具备各种执行条件，只需再获得CPU便可立即执行。</li><li>阻寒状态：线程在执行中因某事件受阻而处于暂停状态。</li></ol></li><li>线程这三种基本状态之间的转换和进程基本状态之间的转换是一样的</li></ol><h3 id="线程的组织与控制"><a href="#线程的组织与控制" class="headerlink" title="线程的组织与控制"></a>线程的组织与控制</h3><ol><li>线程控制块<ol><li>与进程类似，系统也为每个线程配置一个线程控制块TCB,用于记录控制和管理线程的信息。 线程控制块通常包括：①线程标识符；②一组寄存器，包括程序计数器、状态寄存器和通用寄存器；③线程运行状态，用于描述线程正处于何种状态；④优先级；⑤线程专有存储区，线程切换时用于保存现场等；⑥堆栈指针，用于过程调用时保存局部变量及返回地址等。</li><li>同一进程中的所有线程都完全共享进程的地址空间和全局变量。各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。</li></ol></li><li>线程的创建<ol><li>线程也是具有生命期的，它由创建而产生，由调度而执行，由终止而消亡。相应地，在操作系统中就有用于创建线程和终止线程的函数(或系统调用)。</li><li>用户程序启动时，通常仅有一个称为“初始化线程”的线程正在执行，其主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完后，将返回一个线程标识符。</li></ol></li><li>线程的终止<ol><li>，当一个线程完成自己的任务后，或线程在运行中出现异常而要被强制终止时由终止线程调用相应的函数执行终止操作。但是有些线程(主要是系统线程)一旦被建立，便一直运行而不会被终止。通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。</li></ol></li></ol><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><ol><li>用户级线程<ol><li><font color = red>在用户级线程中，有关线程管理(创建、撤销和切换等)的所有工作都由应用程序在用户空间中完成，内核意识不到线程的存在。</font>应用程序可以通过使用线程库设计成多线程程序。通常， 应用程序从单线程开始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。<br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-21-59-32.png"></li><li>这种实现方式的优点如下：①线程切换不需要转换到内核空间，节省了模式切换的开销。②调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。 ③用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。</li><li>这种实现方式的缺点如下：①系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞。②不能发挥多处理机的优势，内核每次分配给一个进程的仅有一个CPU,因此进程中仅有一个线程能执行。</li></ol></li><li>内核级线程<ol><li>在操作系统中，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，与内核紧密相关。内核级线程同样也是在内核的支持下运行的，线程管理的所有工作也是在内核空间内实现的。内核空间也为每个内核级线程设置一个线程控制块，内核根据该控制块感知某线程的存在，并对其加以控制。<br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-21-59-48.png"><br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-21-59-59.png"></li><li>这种实现方式的优点如下：①能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行。②如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机， 也可运行其他进程中的线程。③内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。④内核本身也可采用多线程技术，可以提高系统的执行速度和效率。</li><li>这种实现方式的缺点如下：同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大。这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。</li></ol></li><li>组合方式<ol><li>有些系统使用组合方式的多线程实现。在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。一些内核级线程对应多个用户级线程，这是用户级线程通过时分多路复用内核级线程实现的。同一进程中的多个线程可以同时在多处理机上并行执行，且在阻塞一个线程时不需要将整个进程阻塞，所以组合方式能结合KLT和ULT的优点，并且克服各自的不足。<br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-22-00-42.png"><br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-22-00-49.png"></li><li>在线程实现方式的介绍中，提到了通过线程库来创建和管理线程。线程犀(thread library)<br>是为程序员提供创建和管理线程的API。实现线程库主要的方法有如下两种：<br>※ 在用户空间中提供一个没有内核支持的库。这种摩的所有代码和数据结构都位于用户空间中。这意味着，调用库内的一个函数只导致用户空间中的一个本地函数的调用。<br>※ ②实现由操作系统直接支持的内核级的一个库。对于这种情况，库内的代码和数据结构位于内核空间。调用库中的一个API函数通常会导致对内核的系统调用。</li></ol></li></ol><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><ol><li>多对一模型。<font color = red>将多个用户级线程映射到一个内核级线程</font>，如图2.6(a)所示。这些用户线程一般属于一个进程，线程的调度和管理在用户空间完成。仅当用户线程需要访问内核时， 才将其映射到一个内核级线程上，但是每次只允许一个线程进行映射。 <br>优点：<font color = red>线程管理是在用户空间进行的，因而效率比较高。</font> <br>缺点：<font color = red>如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行</font><br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-22-04-17.png"></li><li>一对一模型。<font color = red>将每个用户级线程映射到一个内核级线程</font>，如图2.6(b)所示。<br>优点：<font color = red>当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强。</font><br>缺点：<font color = red>每创建一个用户线程，相应地就需要创建一个内核线程，开销较大。</font><br><img src="/2023/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-11-22-04-53.png"></li><li><font color = red>多对多模型。将”个用户线程映射到m个内核级线程上，要求n&gt;&#x3D;m,如图2.6(c)所示。</font> <br>特点：既克服了多对一模型并发度不高的<br>缺点，又克服了一对一模型的一个用户进程占<br>用太多内核级线程而开销太大的缺点。此外，还拥有上述两种模型各自的优点。</li></ol><h2 id="本节小节"><a href="#本节小节" class="headerlink" title="本节小节"></a>本节小节</h2><ol><li>为什么要引入进程？<br>在多道程序同时运行的背景下，进程之间需要共享系统资源，因此会导致各程序在执行过程中出现相互制约的关系， 发生的，是动态的过程， 序在内存中的执行情况， 与其他执行程序的关系， 了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。程序的执行会表现出间断性的特征。这些特征都是在程序的执行过程中而传统的程序本身是一组指令的集合，是一个静态的概念，无法描述程即我们无法从程序的字面上看出它何时执行、何时停顿，也无法看出它与其它执行程序的关系，因此，程序这个静态概念已不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念</li><li>什么是进程？进程由什么组成？<br>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码本身，还包括当前的活动， 通过程序计数器的值和处理寄存器的内容来表示。 <br>一个进程实体由程序段、相关数据段和PCB三部分构成，其中PCB是标志一个进程存在的唯一标识，程序段是进程运行的程序的代码，数据段则存储程序运行过程中相关的一些数据。</li><li>进程是如何解决问题的？<br>进程把能够识别程序运行态的一些变量存放在PCB中，通过这些变量系统能够更好地了解进程的状况，并在适当时进行进程的切换，以避免一些资源的浪费，甚至划分为更小的调度单位一线程来提高系统的并发度。</li></ol><h2 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h2><ol><li>进程映像是PCB、程序段和数据的组合，其中PCB是进程存在的唯一标志。</li><li>线程包含CPU现场，可以独立执行程序。因为线程是处理机调度的基本单位，可以独立执行程序。</li><li>线程没有自己独立的地址空间，它共享其所属进程的空间。</li><li>每个进程包含独立的地址空间，进程各自的地址空间是私有的，只能执行自己地址空间中的程序，且只能访问自己地址空间中的数据，相互访问会导致指针的越界错误。因此进程之间不能直接交换数据，但可利用操作系统提供的共享文件、消息传递、共享存储区等进行通信。</li><li>进程获得处理器运行是通过调度得到的。</li><li>优先级分静态和动态两种，动态优先级是根据运行情况而随时调整的。</li><li>系统发生死锁时有可能进程全部都处于阻塞态，CPU空闲。</li><li>进程申请处理器得不到满足时就处于就绪态。</li><li>I&#x2F;O操作之前进程在等待结果，状态为阻塞态；完成后进程等待事件就绪，变为就绪态。</li><li>只有就绪态既可以由运行态转变过去又能由阻塞态转变过去。时间片到，运行态变为就绪态；当所需要资源到达时，进程由阻塞态转变为就绪态。</li><li>程序封闭性是指进程执行的结果只取决于进程本身，不受外界影响。也就是说，进程在执行过程中不管是不停顿地执行，还是走走停停，进程的执行速度都不会改变它的结果。失去封闭性后，不同速度下的执行结果不同。</li><li>并发进程失去封闭性是指并发进程共享变量，其执行结果与速度有关。</li><li>通常用户进程被建立后，随着进程运行的正常或不正常结束而撤销。因为：进程有它的生命周期，不会一直存在于系统中，也不一定需要用户显示地撤销。进程在时间片结束时只是就绪，而不是撤销。阻塞和唤醒是进程生存期的中间状态。进程可在完成时撤销，或在出现内存错误时撤销。</li><li>引入线程后，进程仍然是资源分配的单位。内核级线程是处理器调度和分派的单位，线程本身不具有资源，它可以共享所属进程的全部资源。</li><li>用信箱实现进程间互通信息的通信机制要有两个通信原语，它们是发送原语和接收原语。</li><li>进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位，它包括PCB、 程序和数据以及执行栈区，仅仅说进程是在多程序环境下的完整程序是不合适的，因为程序是静态的，它以文件形式存放于计算机硬盘内，而进程是动态的。</li><li>C语言编写的程序在使用内存时一般分为三个段，它们一般是正文段（即代码和赋值数据段）、数据堆段和数据栈段。二进制代码和常量存放在正文段，动态分配的存储区在数据堆段，临时使用的变量在数据栈段。由此，我们可以确定全局赋值变量在正文段赋值数据段，未赋值的局部变量和实参传递在栈段，动态内存分配在堆段，常量在正文段，进程的优先级只能在PCB内。</li><li>一个计算机系统中，进程的最大数目主要受到内存大小的限制。</li><li>进程创建完成后会进入一个序列，这个序列称为就绪队列</li><li>由进程的状态图可以看出，进程的就绪数目越多，争夺CPU的进程就越多，但只要就绪队列不空，CPU就总是可以调度进程执行，保持繁忙。这与就绪进程的数据没有关系，除非就绪队列为空，此时CPU进入等待态，导致CPU的效率下降。</li><li>线程是进程内一个相对独立的执行单元，但不能脱离进程单独运行，只能在进程中运行。</li><li>引入线程是为了减少时空开销。</li><li>在无线的系统中，进程是资源调度和并发执行的基本单位。在引入线程的系统中，进程退化为资源分配的基本单位，而线程代替了进程被操作系统调度，因而线程可以并发执行。</li><li>不同的进程拥有不同的代码段，全局变量是对同一进程而言的，在不同的进程中是不同的变量，没有任何联系，所以不能用于交换数据。</li><li>管道是一种文件。</li><li>一次I&#x2F;O操作结束——&gt; 阻塞态 –&gt; 就绪态</li><li>运行进程需做I&#x2F;O操作——-&gt; 运行态 –&gt; 就绪态</li><li>运行进程结束——-&gt; 进程撤销</li><li>出现了比现在进程优先级更高的进程——–&gt; 运行态 –&gt; 就绪态</li><li>进程切换是指CPU调度不同的进程执行，当一个进程从运行态变成就绪态时，CPU调度另一个进程执行，引起进程切换。</li><li>在内核级线程中，同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大。</li><li>CPU调度是在内核进行的，在内核级线程中，调度是在线程一级进行的，因此内核可以同时调度同一进程的多个线程在多CPU上并行运行(用户级线程则不行).</li><li>当进程中的内核级线程运行在内核态时，说明该进程也运行在内核态。</li><li>进程中的某个用户级线程被阻塞，则整个进程也被阻塞，即进程中的其他用户级线程也被阻塞</li><li>用户级线程的调度是在用户空间进行的，节省了模式切换的开销，不同进程可以根据自身的需要，对自己的线程选择不同的调度算法。</li><li>启动程序执行是引起创建进程的典型事件</li><li>一个普通管道只允许单向通信，若要实现父子进程双向通信，则需要定义两个管道，而每个管道向不同方向发送数据。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机</title>
    <link href="/2023/05/11/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2023/05/11/%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><h2 id="虚拟机的基本概念"><a href="#虚拟机的基本概念" class="headerlink" title="虚拟机的基本概念"></a>虚拟机的基本概念</h2><p>虚拟机是一台逻辑计算机，是指利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。</p><h3 id="第一类虚拟机管理程序"><a href="#第一类虚拟机管理程序" class="headerlink" title="第一类虚拟机管理程序"></a>第一类虚拟机管理程序</h3><ol><li>从技术上讲，第一类虚拟机管理程序就像一个操作系统，因为它是唯一一个运行在最高特权级的程序。它在裸机上运行并且具备多道程序功能。虚拟机管理程序向上层提供若干台虚拟机， 这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以运行任何不同的操作系统。</li><li>虚拟机作为用户态的一个进程运行，不允许执行敏感指令。然而，虚拟机上的操作系统认为自己运行在内核态（实际上不是），称为虚拟内核态。虚拟机中的用户进程认为自己运行在用户态（实际上确实是）。当虚拟机操作系统执行了一条CPU处于内核态才允许执行的指令时，会陷<br>入虚拟机管理程序。在支持虚拟化的CPU上，虚拟机管理程序检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行。否则，虚拟机管理程序将模拟真实硬件面对用户态执行敏感指令时的行为。</li></ol><h3 id="第二类虚拟机管理程序"><a href="#第二类虚拟机管理程序" class="headerlink" title="第二类虚拟机管理程序"></a>第二类虚拟机管理程序</h3><ol><li>依赖于Windows、Linux等操作系统分配和调度资源的程序，很像一个普通的进程。第二类虚拟机管理程序仍然伪装成具有CPU和各种设备的完整计算机。</li><li>运行在两类虚拟机管理程序上的操作系统都称为客户操作系统。对于第二类虚拟机管理程序，运行在底层硬件上的操作系统称为宿主操作系统。</li><li>首次启动时，第二类虚拟机管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。然后将操作系统安装到虚拟磁盘上（其实只是宿主操作系统中的一个文件）。客户操作系统安装完成后，就能启动并运行。</li><li>虚拟化在Web主机领域很流行。没有虚拟化，服务商只能提供共享托管（不能控制服务器的软件）和独占托管（成本较高）。当服务商提供租用虚拟机时，一台物理服务器就可以运行多个虚拟机，每个虚拟机看起来都是一台完整的服务器，客户可以在虚拟机上安装自己想用的操作系<br>统和软件，但是只需支付较低的费用。这就是市面上常见的“云”主机。<br><img src="/2023/05/11/%E8%99%9A%E6%8B%9F%E6%9C%BA/2023-05-11-21-06-45.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统运行环境</title>
    <link href="/2023/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统运行环境"><a href="#操作系统运行环境" class="headerlink" title="操作系统运行环境"></a>操作系统运行环境</h1><h2 id="处理器运行模式"><a href="#处理器运行模式" class="headerlink" title="处理器运行模式"></a>处理器运行模式</h2><ol><li>在计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统内核程序；另一种是用户自编程序（即系统外层的应用程序，或简称”应用程序”）。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此”管理程序”（即内核程序）要执行一些特权指令，而“被管理程序”（即用户自编程序）出于安全考虑不能执行这些指令。</li><li>两类指令：<ol><li>特权指令，是指不允许用户直接使用的指令，如I&#x2F;O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。</li><li>非特权指令，是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。</li></ol></li><li>在具体实现上，将CPU的运行模式划分为用户态（目态）和核心态（又称管态、内核态）。</li><li>应用程序向操作系统请求服务时通过使用访管指令，从而产生一个中断事件将操作系统转换为核心态。</li></ol><h3 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h3><ol><li>在计算机的各种部件中，时钟是最关键的设备。</li><li>时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现进程的切换。</li></ol><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><ol><li>引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。</li><li>中断机制中，只有一小部分功能属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</li></ol><h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><ol><li>按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。它们的特点如下：<ol><li>处于操作系统的最底层，是最接近硬件的部分。</li><li>这些程序的运行具有原子性，其操作只能一气呵成（出于系统安全性和便于管理考虑）。</li><li>这些程序的运行时间都较短，而且调用频繁。</li></ol></li><li>定义原语的直接方法是关闭中断,让其所有动作不可分割地完成后再打开中断。系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。</li><li></li></ol><h3 id="系统技制的数据结构及处理"><a href="#系统技制的数据结构及处理" class="headerlink" title="系统技制的数据结构及处理"></a>系统技制的数据结构及处理</h3><ol><li>系统中用来登记状态信息的数据结构很多，如作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下3种：<ol><li>进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。</li><li>存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li><li>设备管理。缓冲区管理、设备分配和回收等。</li></ol></li></ol><h2 id="中断和异常的概念"><a href="#中断和异常的概念" class="headerlink" title="中断和异常的概念"></a>中断和异常的概念</h2><h3 id="中断和异常的定义"><a href="#中断和异常的定义" class="headerlink" title="中断和异常的定义"></a>中断和异常的定义</h3><ol><li>中断（Interruption）也称外中断，是指来自CPU执行指令外部的事件，通常用于信息输入&#x2F;输出，如设备发出的I&#x2F;O结束中断，表示设备输入&#x2F;输出处理已经完成。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。</li><li>异常（Exception）也称内中断，是指来自CPU执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件。异常不能被屏蔽，一旦出现，就应立即处理。</li><li>区别<br><img src="/2023/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/2023-05-11-20-27-08.png"></li></ol><h3 id="中断和异常的分类"><a href="#中断和异常的分类" class="headerlink" title="中断和异常的分类"></a>中断和异常的分类</h3><ol><li>外中断可分为可屏蔽中断和不可屏蔽中断。可屏蔽中断是指通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。不可屏蔽中断是指通过NMI线发出的中断请求，通常是紧急的硬件故障，如电源掉电等。此外，异常也是不能被屏蔽的。</li><li>异常可分为故障、自陷和终止。故障（Fault）通常是由指令执行引起的异常，如非法操作码、 缺页故障、除数为0、运算溢出等。自陷（Trap）是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令。终止（Abort）是指出现了使得CPU无法继续执行的硬件故障，如控制器出错、存储器校验错等。故障异常和自陷异常属于软件中断（程序性异常），终止异常和外部中断属于硬件中断。</li></ol><h3 id="中断和异常的处理过程"><a href="#中断和异常的处理过程" class="headerlink" title="中断和异常的处理过程"></a>中断和异常的处理过程</h3><ol><li>中断和异常处理过程的大致描述如下：当CPU在执行用户程序的第i条指令时检测到一个异常事件，或在执行第，•条指令后发现一个中断请求信号，则CPU打断当前的用户程序，然后转到相应的中断或异常处理程序去执行。若中断或异常处理程序能够解决相应的问题，则在中断或异<br>常处理程序的最后，CPU通过执行中断或异常返回指令，回到被打断的用户程序的第，条指令或第7+1条指令继续执行；若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。 通常情况下，对中断和异常的具体处理过程由操作系统（和驱动程序）完成。</li></ol><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><ol><li>系统调用，是指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行I&#x2F;O传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</li><li>系统调用按功能大致可分为如下几类：<ol><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li></ol></li><li>显然，系统调用相关功能涉及系统资源管理、进程管理之类的操作，对整个系统的影响非常大，因此必定需要使用某些特权指令才能完成，所以系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。</li><li>用户程序可以执行陷入指令（又称访管指令或trap指令）来发起系统调用，请求操作系统提供服务。</li><li>系统调用执行过程<br><img src="/2023/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/2023-05-11-20-32-43.png"></li><li>用户态转向核心态的例子：<ol><li>用户程序要求操作系统的服务，即系统调用。</li><li>发生一次中断。</li><li>用户程序中产生了一个错误状态。</li><li>用户程序中企图执行一条特权指令。</li><li>从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。</li></ol></li><li>由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈、但这个系统堆栈也是属于该进程的.</li><li>若程序的运行由用户态转到核心态，则会用到访管指令，访管指令是在用户态使用的，所以它不可能是特权指令。</li></ol><h2 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h2><ol><li>操作系统执行程序时，必须从起始地址开始执行</li><li>当计算机提供了核心态和用户态时，输入&#x2F;输出指令必须在核心态下执行。因为输入&#x2F;输出操作需要中断操作，中断必须在核心态下执行。</li><li>操作系统中，通道技术是一种硬件技术。I&#x2F;O通道实际上是一种特殊的处理器，它具有执行I&#x2F;O指令的能力，并通过执行通道来控制I&#x2F;O操作。</li><li>系统调用需要出发trap指令。</li><li>中断时操作系统必须提供的功能，因为计算机的各种错误都需要中断处理，核心态与用户态切换也需要中断处理。</li><li>内核可以执行处理器能执行的任何指令，用户程序只能执行除特权指令外的指令。所以特权指令只能由内核即操作系统使用。</li><li>进程调度由调度算法决定CPU使用权，由操作系统实现，不需要硬件支持。</li><li>计算机通过硬件中断机制完成由用户态到核心态的转换。</li><li>计算机通过硬件完成操作系统由用户态到核心态的转换，这是通过中断机制来实现的。发生中断事件时(有可能是用户程序发出的系统调用),触发中断，硬件中断机制将计算机状态置为核心态。</li><li>“访管”指令仅在用户态下使用，执行“访管”指令将用户态转变成核心态。</li><li>广义指令即系统调用命令，它必然工作在核心态。</li><li>缺页处理和时钟中断都属于中断，在核心态执行；进程调度是操作系统内核进程，无须用户干预，在核心态执行；命令解释程序属于命令接口，它在用户态执行。</li><li>进程切换不可能在用户态发生。</li><li>子程序调用秩序保存程序断点，即该指令的下一条指令的地址；中断处理不仅要保存断点(pc的内容)，还要保存程序状态字寄存器(PSW)d的内容。</li><li>外部中断处理过程，PC的值由中断隐指令自动保存，而通用寄存器内容由操作系统保存。</li><li>执行系统调用的过程如下：正在运行的进程先传递系统调用参数，然后有陷入(trap)指令负责将用户态转换为内核态，并将返回地址压入堆栈以备后用，接下来CPU执行相应的内核态服务程序，最后返回用户态。</li><li>当CPU检测到中断信号后，由硬件自动保存被中断程序的断点(即程序计数器PC和程序状态字寄存器PSW)</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统发展历程</title>
    <link href="/2023/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
    <url>/2023/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统发展历程"><a href="#操作系统发展历程" class="headerlink" title="操作系统发展历程"></a>操作系统发展历程</h1><h2 id="手工操作阶段（此阶段无操作系统）"><a href="#手工操作阶段（此阶段无操作系统）" class="headerlink" title="手工操作阶段（此阶段无操作系统）"></a>手工操作阶段（此阶段无操作系统）</h2><ol><li>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾（速度和资源利用）越来越大，必须寻求新的解决办法。</li><li>手工操作阶段有两个突出的缺点：①用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。②CPU等待手工操作，CPU的利用不充分。</li></ol><h2 id="批处理阶段（操作系统开始出现）"><a href="#批处理阶段（操作系统开始出现）" class="headerlink" title="批处理阶段（操作系统开始出现）"></a>批处理阶段（操作系统开始出现）</h2><p>为了解决人机矛盾及CPU和I&#x2F;O设备之间速度不匹配的矛盾，出现了批处理系统。按发展历程又分为单道批处理系统、多道批处理系统（多道程序设计技术出现以后）。</p><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p>   系统对作业的处理是成批进行的，但内存中始终保持一道作业。单道批处理系统是在解决人机矛盾及CPU和I&#x2F;O设备速率不匹配的矛盾中形成的。单道批处理系统的主要特征如下：</p><ol><li>自动性。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预。</li><li>顺序性。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成</li><li>单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</li><li>面临的问题：每次主机内存中仅存放一道作业，每当它在运行期间（注意这里是“运行时”而不是“完成后”）发出输入&#x2F;输出请求后，高速的CPU便处于等待低速的I&#x2F;O完成的状态。 为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术</li></ol><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ol><li>多道程序设计技术允许多个程序同时进入内存并允许它们在CPU中交替地运行，这些程序共享系统中的各种硬&#x2F;软件资源。当一道程序因I&#x2F;O请求而暂停运行时，CPU便立即转去运行另一道程序。</li><li>多道程序设计的特点是多道、宏观上并行、微观上串行。<ol><li>多道。计算机内存中同时存放多道相互独立的程序。</li><li>宏观上并行。同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行,但都未运行完毕。</li><li>微观上串行。内存中的多道程序轮流占有CPU,交替执行。</li></ol></li><li>在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统把用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行</li><li>优点：资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用；系统吞吐量大，CPU和其他资源保持“忙碌”状态。缺点：用户响应的时间较长；不提供人机交互能力， 用户既不能了解自己的程序的运行情况，又不能控制计算机。</li></ol><h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><ol><li>所谓分时技术，是指把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行， 把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己独占一台计算机</li><li>分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征。分时系统的主要特征如下：<ol><li>同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li><li>交互性。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</li><li>独立性。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</li><li>及时性。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</li></ol></li></ol><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><ol><li>为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况：若某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为硬实时系统，如飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。若能够接受偶尔违反时间规定且不会引起任何永久性的损害，则称为软实时系统，如飞机订票系统、银行管理系统。</li><li>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件。实时操作系统的主要特点是及时性和可靠性。</li></ol><h2 id="网络操作系统和分布式计算机系统"><a href="#网络操作系统和分布式计算机系统" class="headerlink" title="网络操作系统和分布式计算机系统"></a>网络操作系统和分布式计算机系统</h2><ol><li>网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。</li><li>分布式计算机系统是由多台计算机组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息；系统中的每台计算机都具有同等的地位，即没有主机也没有从机；每台计算机上的资源为所有用户共享；系统中的任意台计算机都可以构成一个子系统，并且还能重构；任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是：分布性和并行性。分布式操作系统与网络操作系统的本质不同是，分布式操作系统中的若干计算机相互协同完成同一任务。</li></ol><h2 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h2><p><img src="/2023/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/2023-05-11-20-12-56.png"></p><h2 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h2><ol><li>脱机技术用于解决独占设备问题。虚拟技术与交换技术以多道程序设计技术为前提。多道程序设计技术由于同时在主存中运行多个程序，在一个程序等待时，可以去执行其他程序，因此提高了系统资源的利用率。</li><li>批处理系统中，作业执行时用户无法干预其运行，只能通过事先编制作业控制说明书来间接干预，缺少交互能力，也因此才有了分时操作系统的出现。</li><li>多道程序的运行环境比单道程序的运行环境更加复杂。引入多道程序后，程序的执行就失去了封闭性和顺序性。程序执行因为共享资源及相互协同的原因产生了竞争，相互制约。</li><li>操作系统的基本类型主要有批处理操作系统、分时操作系统和实时操作系统。</li><li>实时系统的进程调度，通常采用抢占式的优先级高者优先。实时系统必须能足够及时地处理某些紧急的外部事件，因此普遍用高优先级，并用“可抢占”来确保实时处理。</li><li>采用优先级+非抢占式调度算法，既可让重要的作业&#x2F;进程通过高优先级尽快获得系统响应， 又可保证次要的作业&#x2F;进程在非抢占式调度下不会迟迟得不到系统响应，这样有利于改善系统的响应时间。加大时间片会延迟系统响应时间；静态页式管理和代码可重入与系统响应时间无关。</li><li>在分时操作系统中，响应时间是衡量一个分时系统的一项重要指标。响应时间是指用户提交请求到系统开始响应用户请求所需的时间。分时操作系统旨在为多个用户提供快速响应，因此响应时间是衡量分时系统性能的重要指标之一。</li><li>实时操作系统的目的是在特定时间内完成特定任务，确保系统的及时响应和快速处理。因此，在设计实时操作系统时，重点考虑的是及时响应、快速处理、高安全性和高可靠性，而不是提高系统资源的利用率。</li><li>用户程序中的输入，输出操作实际上是由操作系统完成。操作系统提供了一组用于输入和输出的系统调用，这些调用可以被用户程序调用以执行输入和输出操作。例如，在 UNIX 系统中，read 和 write 系统调用可用于执行文件读写操作。</li><li>计算机系统中判别是否有中断事件发生应是在执行完一条指令后。中断是一种硬件机制，用于通知处理器有外部事件需要处理。当处理器执行完一条指令后，它会检查是否有中断事件发生。如果有中断事件发生，处理器会保存当前的执行状态，然后跳转到中断处理程序来处理中断。</li><li>设计批处理多道系统时，首先要考虑的是系统效率和吞吐量。批处理多道系统旨在通过同时运行多个作业来提高系统效率和吞吐量。因此，在设计批处理多道系统时，应首先考虑如何最大化系统效率和吞吐量，以便在单位时间内完成尽可能多的作业。</li><li>若当前进程因时间片用完而让出处理机时，该进程应转变为就绪 状态。当一个进程的时间片用完时，它会被操作系统调度程序从运行状态转换为就绪状态，等待下一次调度。在就绪状态下，进程已经准备好运行，但是还没有获得处理器资源。</li><li>采用多道程序设计能减少处理器空闲时间。多道程序设计允许多个程序同时驻留在内存中并交替执行，从而在一个程序等待I&#x2F;O操作完成时，处理器可以切换到另一个程序继续执行，减少了处理器的空闲时间。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的基本概念</title>
    <link href="/2023/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h1><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><ol><li>操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。</li></ol><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><p>   操作系统是一种系统软件，但与其他系统软件和应用软件有很大的不同，它有自己的特殊性即基本特征。操作系统的基本特征包括并发、共享、虚拟和异步。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ol><li>并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的是使程序能并发执行。</li><li>注意同一时间间隔(并发)和同一时刻(并行)的区别。在多道程序环境下，一段时间内， 宏观上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行，因此微观上这些程序仍是分时交替执行的。操作系统的并发性是通过分时得以实现的。</li><li>注意，并行性是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。</li></ol><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>   资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可分为互斥共享方式和同时访问方式。</p><h4 id="互斥共享方式"><a href="#互斥共享方式" class="headerlink" title="互斥共享方式"></a>互斥共享方式</h4><p>1.系统中的某些资源，如打印机、磁带机，虽然可供多个进程使用，但为使得所打印或记录的结果不致造成混淆，应规定在一•段时间内只允许一个进程访问该资源。<br>2.当进程A访问某个资源时，必须先提出请求，若此时该资源空闲，则系统便将之分配给进程A使用，此后有其他进程也要访问该资源时(只要A未用完)就必须等待。仅当进程A访问完并释放该资源后，才允许另一个进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源。计算机系统中的大多数物理设备及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。</p><h4 id="同时访问方式"><a href="#同时访问方式" class="headerlink" title="同时访问方式"></a>同时访问方式</h4><ol><li>系统中还有另一类资源，这类资源允许在一段时间内由多个进程“同时”访问。这里所说的“同时”通常是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。可供多个进程“同时”访问的典型资源是磁盘设备，一些用重入码编写的文件也可被”同时”共享，即允许若干个用户同时访问该文件。</li></ol><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>并发和共享是操作系统两个最基奎的特征，两者之间互为存在的条件：①资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；②若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</p><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><ol><li>虚拟是指把一个物理上的实体变为若干逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。操作系统中利用了多种虚拟技术来实现虚拟处理器、虚拟内存和虚拟外部设备等。</li><li>操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术， 如虚拟存储器。</li></ol><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ol><li>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</li><li>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误（就像对全局变量的访问顺序不当会导致程序出错一样）。然而，只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。</li></ol><h2 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h2><p>为了给多道程序提供良好的运行环境，操作系^^应具有以下几方面的功能：处理机管理、存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。“同时， 操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p><h3 id="操作系统作为计算机系统资源的管理者"><a href="#操作系统作为计算机系统资源的管理者" class="headerlink" title="操作系统作为计算机系统资源的管理者"></a>操作系统作为计算机系统资源的管理者</h3><ol><li>处理机管理<br>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。并发是指在计算机内同时运行多个进程，因此进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</li><li>存储器管理<br>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率， 主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</li><li>文件管理<br>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。 文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</li><li>设备管理<br>设备管理的主要任务是完成用户的I&#x2F;O请求，方便用户使用各种设备，并提高设备的利用率， 主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</li></ol><h3 id="操作系统作为用户与计算机硬件系统之间的接口"><a href="#操作系统作为用户与计算机硬件系统之间的接口" class="headerlink" title="操作系统作为用户与计算机硬件系统之间的接口"></a>操作系统作为用户与计算机硬件系统之间的接口</h3><p>为了让用户方便、快捷、可靠地操纵计算机硬件并运行自己的程序，操作系统还提供了用户接口。操作系统提供的接口主要分为两类：一类是命令接口，用户利用这些操作命令来组织和控制作业的执行；另一类是程序接口，编程人员可以使用它们来请求操作系统服务。</p><h4 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h4><ol><li>使用命令接口进行作业控制的主要方式有两种，即联机控制方式和脱机控制方式。按作业控制方式的不同，可将命令接口分为联机命令接口和脱机命令接口。</li><li>联机命令接口又称交互式命令接口，适用于分时或实时系统的接口。</li><li>脱机命令接口又称批处理命令接口，适用于批处理系统，它由一组作业控制命令组成。</li></ol><h4 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h4><ol><li>程序接口由一组系统调用(也称广义指令)组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。</li></ol><h3 id="操作系统实现了对计算机资源的扩充"><a href="#操作系统实现了对计算机资源的扩充" class="headerlink" title="操作系统实现了对计算机资源的扩充"></a>操作系统实现了对计算机资源的扩充</h3><p>没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器；因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机</p><h2 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h2><ol><li>操作系统管理计算机的硬件和软件资源，这些资源统称为计算机资源。注意，操作系统不仅管理处理机、存储器等硬件资源，而且也管理文件，文件不属于硬件资源，但属于计算机资源。</li><li>操作系统最基本的特征是并发和共享，两者互为存在条件。</li><li>并发性是指若干事件在同一时间间隔内发生，而并行性是指若干事件在同一时刻发生。</li><li>操作系统主要向用户提供命令接口和程序接口(系统调用)，此外还提供图形接口；当然，图形接口其实是调用了系统调用而实现的功能。</li><li>系统调用是操作系统为应用程序使用内核功能所提供的接口。</li><li>操作系统为编程人员提供的接口是程序接口，即系统调用</li><li>系统调用的目的是请求系统服务。操作系统不允许用户直接操作各种硬件资源，因此用户程序只能通过系统调用的方式来请求内核为其服务，间接地使用各种资源。</li><li>程序接口、图形接口与命令接口三者并没有从属关系。按命令控制方式的不同，命令接口分为联机用户接口和脱机用户接口。</li><li>操作系统通过系统调用向用户程序提供服务，文件I&#x2F;O需要在内核态运行。</li><li>广义指令就是系统调用命令，而命令解释器属于命令接口，shell是命令解析器，他也属于命令接口。系统中的缓存全部由操作系统管理，对用户是透明的，操作系统不提供管理系统缓存的系统调用。</li><li>引入多道程序设计后，程序的执行就失去了封闭性和顺序性。程序执行因为共享资源及相互协同的原因产生了竞争，相互制约。考虑到竞争的公平性，程序的执行是断续的。顺序性是单道程序设计的基本特征。</li><li>在单处理机系统中，同一时刻只能有一个进程占用处理机，因此进程之间不能并行执行。通道是独立于CPU的、控制输入&#x2F;输出的设备，两者可以并行。显然，处理器与设备是可以并行的。设备与设备是可以并行的，比如显示屏与打印机是可以并行工作的。</li><li>库函数属于用户程序而非系统调用，是系统调用的上层。</li><li>系统开机后，操作系统的程序会被自动加载到内存中的系统区，这段区域是RAM。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>外部排序</title>
    <link href="/2023/05/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/05/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol><li>外部排序：数据元素太多，无法一次全部读入内存进行排序</li><li>使用归并排序的方法，最少只需在内存中分配3块大小的 缓冲区即可对任意一个大文件进行排序</li><li>若要进行k路归并排序，则需要在内存中分配k个输入缓冲区和1个输出缓冲区</li><li>步骤<ol><li>生成r个初始归并段(对L个记录进行内部排序，组成一个有序的初始归并段)</li><li>进行S趟k路归并，S &#x3D; [ log<sub>k</sub><sup>r</sup> ] (向上取整)</li></ol></li><li>如何进行k路归并<ol><li>把k个归并段的块读入k个输入缓冲区</li><li>用“归并排序”的方法从k个归并段中选出几个最小的记录暂存到输出缓冲区中</li><li>当输出缓冲区满时，写出外存</li></ol></li><li>外部时间开销：<br>※ 读写外存时间 + 内部排序所需时间 + 内部归并所需时间</li><li>优化：<ol><li>增加归并路数k，进行多路平衡归并<br>※ 代价1：需要增加相应的输入缓冲区<br>※ 代价2：每次从k个归并段中选一个最小元素需要(k-1)次关键字对比</li><li>减少初始归并段数量r</li></ol></li><li>k路平衡归并<ol><li>最多只能有k个段归并为一个</li><li>每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到[ m&#x2F;k ] (向上取整) 个新的归并段</li></ol></li><li>重要结论：</li><li><img src="/2023/05/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/2023-05-11-16-31-23.png"></li></ol><h2 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h2><h3 id="重要思想"><a href="#重要思想" class="headerlink" title="重要思想"></a>重要思想</h3><ol><li>多路平衡归并带来的问题<br><img src="/2023/05/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/2023-05-11-16-37-33.png"></li><li>什么是败者树<br>可视为一颗完全二叉树（多了一个头头）。k个叶结点分别是当前参加比较的元素，非叶结点用来记录左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根节点</li><li>败者树在多路平衡归并中的应用<ol><li>对于k路归并，第一次构造败者树需要对比关键字k-1次</li><li>有了败者树，选出最小元素，只需要对比关键字[ log<sub>2</sub><sup>k</sup> ] (向上取整)次</li></ol></li></ol><h2 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h2><h3 id="重要思想-1"><a href="#重要思想-1" class="headerlink" title="重要思想"></a>重要思想</h3><ol><li>由于内部排序的内存工作区WA可容纳L个记录，则每个初始归并段也只能包含L个记录，若文件共有n个记录，则初始归并段的数量r &#x3D; n &#x2F; L。</li><li>算法执行过程<br><img src="/2023/05/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/2023-05-11-17-00-59.png"></li></ol><h2 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h2><h3 id="重要思想-2"><a href="#重要思想-2" class="headerlink" title="重要思想"></a>重要思想</h3><ol><li>归并树<br><img src="/2023/05/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/2023-05-11-17-04-55.png"></li><li>构造2路归并的最佳归并树<br><img src="/2023/05/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/2023-05-11-17-07-49.png"></li><li>多路归并<br><img src="/2023/05/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/2023-05-11-17-09-12.png"></li><li>注意 ——&gt; 对于k叉归并，若初始归并段的数量无法构成严格的k叉归并树，则需要补充几个长度为0的“虚段”，再进行k叉哈夫曼树的构造<br><img src="/2023/05/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/2023-05-11-17-13-21.png"></li><li>添加虚段的数量<br><img src="/2023/05/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/2023-05-11-17-15-51.png"></li></ol><h3 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h3><ol><li>置换-选择排序是外部排序中生成初始归并段的方法，用此方法得到的初始归并段的长度是不等长的，其长度平均是传统等长初始段的2倍，从而使得初始归并段数减少到原来的近二分之一。但是，置换-选择排序不是一种完整的生成有序文件的外部排序算法。</li><li>最佳归并树在外部排序中的作用是设计m路归并排序的优化方案，仿照哈夫曼树的方法，以初始归并段的长度为权值，构造具有最小带权路径长度的m叉哈夫曼树，可以有效减少归并过程中的读写记录数，加快外部排序的速度。</li><li>在外部排序过程中输入&#x2F;输出缓冲区就是排序的内存工作区，例如做m路平衡归并需要m个输入缓冲区和1个输出缓冲区，用以存放参加归并的和归并完成的记录。在产生初始归并段时也可以作内部排序的工作区</li><li>在做m路平衡归并排序的过程中，为实现输入&#x2F;输出的并行处理，需要设置2m个输入缓冲区和2个输出缓冲区，以便在执行内部归并时，能同时进行输入&#x2F;输出操作。若仅设置m个缓冲区，则仅能进行串行操作，无法并行处理。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第八章 排序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>各种内部排序算法的比较及应用</title>
    <link href="/2023/05/11/%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2023/05/11/%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="各种内部排序算法的比较及应用"><a href="#各种内部排序算法的比较及应用" class="headerlink" title="各种内部排序算法的比较及应用"></a>各种内部排序算法的比较及应用</h1><h2 id="内部排序算法的比较"><a href="#内部排序算法的比较" class="headerlink" title="内部排序算法的比较"></a>内部排序算法的比较</h2><ol><li>从时间复杂度看:简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为O(n)，且实现过程也较为简单，但直接插入排序和冒泡排序最好情况下的时间复杂度可以达到O(n)，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的数据都可以达到很高的效率，但目前未得出其精确的渐近时间。堆排序利用了一种称为堆的数据结构，可以在线性时间内完成建堆，且在 O(nlog<sub>2</sub><sup>n</sup>)内完成排序过程。快速排序基于分治的思想虽然最坏情况下的时间复杂度会达到 0(n<sup>2</sup>)，但快排的平均性能可以达到 O(nlog<sub>2</sub><sup>n</sup>)，在实际应用中常常优于其他排序算法。归并排序同样基于分治的思想，但由于其分割子序列与初始序列的排列无关，因此它的最好、最坏和平均时间复杂度均为 O(nlog<sub>2</sub><sup>n</sup>)。</li><li>从空间复杂度看:简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需借助常数个辅助空间。快速排序需要借助一个递归工作栈，平均大小为 O(log<sub>2</sub><sup>n</sup>)，当然在最坏情况下可能会增长到 O(n)2路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为 O(n)虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。</li><li>从稳定性看:插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。平均时间复杂度为 O(nlog<sub>2</sub><sup>n</sup>)的稳定排序算法只有归并排序，对于不稳定的排序方法，只需举出一个不稳定的实例即可。对于排序方法的稳定性，读者应能从算法本身的原理上去理解，而不应拘泥于死记硬背.</li><li>从过程特征看:采用不同的排序算法，在一次循环或几次循环后的排序结果可能是不同的考研题中经常出现给出一个待排序的初始序列和已经部分排序的序列，问其采用何种排序算法这就要对各类排序算法的过程特征十分熟悉，如冒泡排序和堆排序在每趟处理后都能产生当前的最大值或最小值，而快速排序一趟处理至少能确定一个元素的最终位置等.</li></ol><h2 id="各种排序算法的性质"><a href="#各种排序算法的性质" class="headerlink" title="各种排序算法的性质"></a>各种排序算法的性质</h2><p><img src="/2023/05/11/%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%8F%8A%E5%BA%94%E7%94%A8/2023-05-11-13-40-13.png"></p><h2 id="内部排序算法的应用"><a href="#内部排序算法的应用" class="headerlink" title="内部排序算法的应用"></a>内部排序算法的应用</h2><ol><li>选取排序方法需要考虑的因素<ol><li>待排序的元素数目n。</li><li>元素本身信息量的大小</li><li>关键字的结构及其分布情况</li><li>稳定性的要求</li><li>语言工具的条件，存储结构及辅助空间的大小等。</li></ol></li><li>排序算法小结</li><li>若n较小，可采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动次数较简单选择排序的多，因而当记录本身信息量较大时，用简单选择排序较好。</li><li>若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。</li><li>若n较大，则应采用时间复度为0(nlog<sub>2</sub><sup>n</sup>)的排序方法:快速排序排序或归并排序。快速排序被认为是目前基于比较的内部排序方法中最好的方法，当待排序的关键字随机分布时，快速排序的平均时间最短。堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的。若要求排序稳定且时间复杂度为O(nlog<sub>2</sub><sup>n</sup>)，则可选用归并排序。但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后两两归并。直接插入排序是稳定的因此改进后的归并排序仍是稳定的。</li><li>在基于比较的排序方法中，每次比较两个关键字的大小之后，仅出现两种可能的转移因此可以用一棵二叉树来描述比较判定过程，由此可以证明:当文件的n个关键字随机分布时，任何借助于“比较”的排序算法，至少需要 O(nlog<sub>2</sub><sup>n</sup>)的时间</li><li>若n 很大，记录的关键字位数较少且可以分解时，采用基数排序较好。</li><li>当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构</li></ol><h2 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h2><ol><li>基数排序不能对float和double类型的实数进行排序。</li><li>堆排序和快速排序不是稳定排序方法。</li><li>交换类的排序，其趟数和原始序列状态有关，故冒泡排序与初始序列有关。直接插入排序：每趟排序都插入一个元素，所以排序趟数固定为n-1；简单选择排序：每趟都选出一个最小(或最大)的元素，所以排序趟数固定为n-1；基数排序：每趟排序都要进行“分配”和“收集”，排序趟数固定为d。</li><li>插入排序和选择排序的排序趟数始终为n-1，与初始序列无关。</li><li>插入排序、选择排序、冒泡排序的原本时间复杂度为O(n<sup>2</sup>),更换为链式存储后的时间复杂度还是O(n<sup>2</sup>)。希尔排序和堆排序都利用了顺序存储的随机访问特性，而链式存储不支持这种性质，所以时间复杂度会增加。</li><li>选择一个排序算法时，除算法的时空效率外，还需要考虑的是数据的规模、数据的存储方式、算法的稳定性、数据的初始状态。</li><li>直接插入排序和快速排序的特点如下表</li></ol><table><thead><tr><th align="center"></th><th align="center">适合初始序列情况</th><th align="center">适合元素数量</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">直接插入排序</td><td align="center">大部分元素有序</td><td align="center">较少</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">基本无序</td><td align="center">较多</td><td align="center">O(log<sub>2</sub><sup>n</sup>)</td><td align="center">不稳定</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第八章 排序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>归并排序和基数排序</title>
    <link href="/2023/05/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/05/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>“归并”的含义是将两个或两个以上的有序表合并成一个新的有序表。</li><li>假定待排序表含有n个记录，则可将其视为n个有序的子表，每个子表的长度为1，然后两两归并，得到[n&#x2F;2] (向上取整)个长度为2或1的有序表；继续两两归并…….如此重复，直到合并成一个长度为n的有序表为止。</li><li>Merge()的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表A[low…mid]、A[mid+1…high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B中。每次从对应B中的两个段取出一个记录进行关键字的比较，将较小者放入A中，当数组B中有一段的下标超出其对应的表长（即该段的所有元素都已复制到A中）时，将另一段中的剩余部分直接复制到A中。</li><li>一趟归并排序的操作是，调用[n&#x2F;2h] (向上取整)次算法merge(),将L[1…n]中前后相邻且长度为h的有序段进行两两归并，得到前后相邻、长度为 2h的有序段，整个归并排序需要进行[ log<sub>2</sub><sup>n</sup> ] (向上取整)趟。</li><li>递归形式的2路归并排序算法是基于分治的，其过程如下：<ol><li>分解：将含有n个元素的待排序表分成各含n&#x2F;2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。</li><li>合并两个已排序的子表得到排序结果。</li></ol></li></ol><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ElemType *B = (ElemType *)<span class="hljs-built_in">malloc</span>((n + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(ElemType));   <span class="hljs-comment">//辅助数组B</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(ElemType A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-comment">//表A的两段A[low...mid] 和 A[mid+1...high] 各自有序，将它们合并成一个有序表</span><br>    <span class="hljs-type">int</span> i,j,<span class="hljs-function">k</span><br><span class="hljs-function">    <span class="hljs-title">for</span><span class="hljs-params">(k = low;k &lt;= high;k ++)</span></span><br><span class="hljs-function">        B[k] </span>= A[k];                        <span class="hljs-comment">//将A中所有元素复制到B中</span><br>    <span class="hljs-keyword">for</span>(i = low,j = mid + <span class="hljs-number">1</span>,k = i;i &lt;= mid &amp;&amp; j &lt;= high;k ++)&#123;<br>        <span class="hljs-keyword">if</span>(B[i] &lt;= B[j])                    <span class="hljs-comment">//比较B的左右两段中的元素</span><br>            A[k] = B[i ++];                 <span class="hljs-comment">//将较小值复制到A中</span><br>        <span class="hljs-keyword">else</span> <br>            A[k] = B[j ++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)     A[k ++] = B[i ++];  <span class="hljs-comment">//若第一个表未检测完，复制</span><br>    <span class="hljs-keyword">while</span>(j &lt;= high)    A[k ++] = B[j ++];  <span class="hljs-comment">//若第二个表未检测完，复制</span><br>&#125;<br><span class="hljs-comment">//上面的代码中，最后两个while循环只有一个会执行。</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(ElemType A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>        <span class="hljs-type">int</span> mid = (low + high / <span class="hljs-number">2</span>);          <span class="hljs-comment">//从中间划分两个子序列</span><br>        <span class="hljs-built_in">MergeSort</span>(A,low,mid);                <span class="hljs-comment">//对左侧子序列进行递归排序</span><br>        <span class="hljs-built_in">MergeSort</span>(A,mid+<span class="hljs-number">1</span>,high);             <span class="hljs-comment">//对右侧子序列进行递归排序</span><br>        <span class="hljs-built_in">Merge</span>(A,low,mid,high);               <span class="hljs-comment">//归并</span><br>    &#125;<span class="hljs-comment">//if</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ol><li>空间效率：Merge()操作中，辅助空间刚好为n个单元，所以算法的空间复杂度为O(n).</li><li>时间效率：每趟归并的时间复杂度为O(n),共需进行[ log<sub>2</sub><sup>n</sup> ] 趟归并，所以算法的时间复杂度为O(nlog<sub>2</sub><sup>n</sup>).</li><li>稳定性：由于Merge()操作不会改变相同关键字记录的相对次序，所以2路归并排序算法是一种稳定的排序方法。</li><li>注意:一般而言，对于N个元素进行k路归并时，排序的趟数m满足 k<sup>m</sup> &#x3D; N ,从而 m &#x3D; log<sub>k</sub><sup>m</sup>,又考虑到m为整数，所以m &#x3D; [ log<sub>k</sub><sup>m</sup> ]。</li></ol><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>基数排序是一种很特别的排序方法，它不基于比较和移动进行排序，而基于关键字各位的大小进行排序</li><li>假设长度为n的线性表中每个结点a<sub>j</sub>的关键字由d元组(k<sub>j</sub><sup>d-1</sup>,k<sub>j</sub><sup>d-2</sup>,…,k<sub>j</sub><sup>1</sup>,k<sub>j</sub><sup>0</sup>)组成，满足 0 &lt;&#x3D; k<sub>j</sub><sup>i</sup>&gt; &lt;&#x3D; r-1 (0 &lt;&#x3D; j &lt; n,0 &lt;&#x3D; i &lt;&#x3D; d-1)。其中k<sub>j</sub><sup>d-1</sup>为最主关键字，k<sub>j</sub><sup>0</sup>为最次关键字</li><li>为实现多关键字排序，通常有两种方法：<ol><li>第一种是最高位优先(MSD)法，按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列。</li><li>第二种是最低位优先(LSD)法，按关键字位权重递增依次进行排序，最后形成一个有序序列。</li></ol></li></ol><h3 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h3><ol><li>空间效率：一趟排序需要的辅助存储空间为r(r个队列：r个队头指针和r个队尾指针)，但以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为O(r).</li><li>时间效率：基数排序需要进行d趟分配和收集，一趟分配需要O(n),一趟收集需要O(r),所以基数排序的时间复杂度为O(d(n+r)),它与序列的初始状态无关。</li><li>稳定性：对于基数排序算法而言，很重要一点就是按位排序时必须是稳定的。因此，这也保证了基数排序的稳定性。</li></ol><h3 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h3><ol><li>插入排序和归并排序都不能保证在一趟排序结束后一定有元素放在最终的位置上。</li><li>归并排序算法在平均情况下和最坏情况下的空间复杂度都会达到O(n),快速排序只在最坏情况下才会达到O(n),平均情况下为O(log<sub>2</sub><sup>n</sup>).</li><li>选择排序的比较次数与序列初始状态无关，归并排序的比较次数的数量级也与序列的初始状态无关。</li><li>归并排序代码比选择插入排序更复杂，前者的空间复杂度是O(n),后者是O(1)。但前者的时间复杂度是O(nlog<sub>2</sub><sup>n</sup>),后者是O(n<sup>2</sup>).</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第八章 排序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2023/05/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/05/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>假设排序表为L[1…n],第i趟排序即L[i…n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n - 1 趟排序就可使得整个排序表有序。</p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(ElemType A[],<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">1</span>;i ++)&#123;              <span class="hljs-comment">//一共进行 n - 1 趟</span><br>        <span class="hljs-type">int</span> min = i;                            <span class="hljs-comment">//记录最小元素的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt; n;j ++)           <span class="hljs-comment">//在A[i...n-1]中选择最小的元素</span><br>            <span class="hljs-keyword">if</span>(A[j] &lt; A[min]) min = j;          <span class="hljs-comment">//更新最小元素的位置</span><br>        <span class="hljs-keyword">if</span>(min != i) <span class="hljs-built_in">swap</span>(A[i],A[min]);         <span class="hljs-comment">//封装的swap()函数共移动3次</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ol><li>空间效率：仅使用常数个辅助单元，故空间效率为O(1).</li><li>时间效率：从上述伪代码中不难看出，在简单选择排序过程中，元素移动的操作次数很少，不会超过3(n - 1)次，最好的情况是移动0次，此时对应的表已有序；但元素比较的次数与序列的初始状态无关，始终是 n(n - 1) &#x2F; 2 次，因此时间复杂度始终是O(n<sup>2</sup>)。</li><li>稳定性：简单选择排序是一种不稳定的排序方法。</li></ol><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>堆的定义：<br>若n个关键字序列L[1…n]满足下面某一条性质，则称为堆(Heap)<br>①若满足：L(i) &gt;&#x3D; L(2i) 且L(i) &gt;&#x3D; L(2i + 1) ( 1 &lt;&#x3D; i &lt;&#x3D; n&#x2F;2)—-&gt; 大根堆(大顶堆) 根&gt;左&gt;右。<br>②若满足：L(i) &lt;&#x3D; L(2i) 且L(i) &lt;&#x3D; L(2i + 1) ( 1 &lt;&#x3D; i &lt;&#x3D; n&#x2F;2)—-&gt; 小根堆(小顶堆)。<br><img src="/2023/05/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/2023-05-10-21-03-05.png"></li><li>大根堆的建立<ol><li>思路：把所有非终端结点都检查一遍(从后往前扫描)，是否满足大根堆的要求，如果不满足，则进行调整</li><li>在顺序存储的完全二叉树中，非终端结点编号为i &lt;&#x3D; [n&#x2F;2] 向下取整</li><li>i的左孩子—–&gt; 2i<br>i的右孩子—–&gt; 2i + 1<br>i的父节点—–&gt; [i&#x2F;2] 向下取整</li><li>检查当前结点是否满足 根 &gt;&#x3D; 左、右。若不满足，将当前结点与更大的一个孩子互换。 </li><li>若元素互换破坏了下一级的堆，则应采用相同的方式继续往下调整(小元素不断“下坠”)</li></ol></li><li>堆排序<ol><li>每一趟将堆顶元素加入有序子序列(与待排序序列中的最后一个元素交换)</li><li>并将待排序元素序列再次调整为大根堆(小元素不断“下坠”)</li><li>基于“大根堆”的堆排序得到“递增序列”</li><li>基于“小根堆”的堆排序得到“递减序列”</li></ol></li><li>在堆中插入新元素<ol><li>对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。新元素就这样一路“上升”，直到无法继续上升为止。</li></ol></li><li>在堆中删除元素<br>1.被删除的元素用堆底元素替代，然后让该元素不断“下坠”，直到无法下坠为止。</li></ol><h3 id="模板代码-1"><a href="#模板代码-1" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//建立大根堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BuildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span>;i &gt; <span class="hljs-number">0</span>;i --)<br>    <span class="hljs-built_in">HeadAdjust</span>(A,i,len);<br>&#125;<br><br><span class="hljs-comment">//将以 k 为根的子树调整为大根堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeadAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    A[<span class="hljs-number">0</span>] = A[k];                        <span class="hljs-comment">//A[0]暂存子树的根结点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> * k;i &lt;= len;i *= <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//沿key较大的子结点向下筛选</span><br>        <span class="hljs-keyword">if</span>(i &lt;len &amp;&amp; A[i] &lt; A[i + <span class="hljs-number">1</span>])<br>            i++;                        <span class="hljs-comment">//取key较大的子结点的下表</span><br>        <span class="hljs-keyword">if</span>(A[<span class="hljs-number">0</span>] &gt; A[i]) <span class="hljs-keyword">break</span>;          <span class="hljs-comment">//筛选结束</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            A[k] = A[i];<br>            k = i;                      <span class="hljs-comment">//修改k值，以便继续向下筛选</span><br>        &#125;<br>    &#125;<br>    A[k] = A[<span class="hljs-number">0</span>];                        <span class="hljs-comment">//被筛选结点的值放入最终位置</span><br>&#125;<br><br><span class="hljs-comment">//堆排序的完整逻辑</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-built_in">BuildMaxHeap</span>(A,len);                <span class="hljs-comment">//初始建堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len;i &gt; <span class="hljs-number">1</span>;i --)&#123;        <span class="hljs-comment">//n-1趟的交换和建堆的过程</span><br>        <span class="hljs-built_in">swap</span>(A[i],A[<span class="hljs-number">1</span>]);                <span class="hljs-comment">//堆顶元素和堆底元素交换</span><br>        <span class="hljs-built_in">HeadAdjust</span>(A,<span class="hljs-number">1</span>,i - <span class="hljs-number">1</span>);          <span class="hljs-comment">//把剩余的待排序元素整理成堆</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><ol><li>建堆的过程，关键字对比次数不超过4n，建堆时间复杂度 &#x3D; O(n)。</li><li>空间效率：仅使用了常数个辅助单元，所以空间复杂度为O(1).</li><li>时间效率：建堆时间为O(n),之后有n-1次向下调整操作，每次调整的时间复杂度为O(h),故在最好、最坏和平均情况下，堆排序的时间复杂度为O(nlog<sub>2</sub><sup>n</sup>)。</li><li>稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种不稳定的排序算法。</li></ol><h3 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h3><ol><li>简单选择排序算法的比较次数为O(n<sup>2</sup>),移动次数为O(n).</li><li>小根堆关键字最大的记录一定存储在这个堆所对应的完全二叉树的叶结点中；又因为二叉树中的最后一个非叶结点存储在<a href="%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4">n&#x2F;2</a>中，所以关键字最大记录的存储范围为[n&#x2F;2] + 1 ~ n。</li><li>向具有n个结点的堆中插入一个新元素的时间复杂度为O(log<sub>2</sub><sup>n</sup>),删除一个元素的时间复杂度为O(log<sub>2</sub><sup>n</sup>)。</li><li>构建n个记录的初始堆，其时间复杂度为O(n);对n个记录进行堆排序，最坏情况下其时间复杂度为O(nlog<sub>2</sub><sup>n</sup>)。</li><li>堆中输出两个最小关键码 ——-&gt; 说明是小根堆</li><li>选择排序算法的比较次数始终为n(n-1)&#x2F;2,与序列初始状态无关</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第八章 排序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换排序</title>
    <link href="/2023/05/10/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/05/10/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>从后往前(或从前往后)两两比较相邻元素的值，若为逆序(即A[i - 1] &gt; A[i]),则交换他们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序的第一个位置(或将最大的元素交换到待排序序列的最后一个位置)，关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”(或关键字最大的元素如石头一般下沉至水底)。下一趟冒泡时，前一趟确定的最小元素不在参与比较，每趟冒泡的结果是把序列中最小元素或(最大元素)放到序列的最终位置…….这样最多做n - 1趟冒泡就能把所有元素排好序。</p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSore</span><span class="hljs-params">(ElemType A[],<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">1</span>;i ++)&#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;                  <span class="hljs-comment">//表示本趟冒泡是否发生交换的标志</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>;j &gt; i;j --)       <span class="hljs-comment">//一趟冒泡过程</span><br>            <span class="hljs-keyword">if</span>(A[j - <span class="hljs-number">1</span>] &gt; A[j])&#123;            <span class="hljs-comment">//若为逆序</span><br>                <span class="hljs-built_in">swap</span>(A[j - <span class="hljs-number">1</span>],A[j]);        <span class="hljs-comment">//交换    </span><br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">return</span> ;                        <span class="hljs-comment">//本趟遍历后没有发生交换，说明表已经有序</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ol><li>空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)。</li><li>时间效率：最坏情况下的时间复杂度为O(n<sup>2</sup>),平均时间复杂度为O(n<sup>2</sup>)。</li><li>稳定性： 由于i &gt; j  且 A[i] &#x3D; A[j] 时，不会发生交换，因此冒泡排序是一种稳定的排序方法。</li><li>注意：冒泡排序中所产生的有序子序列一定是全局有序的(不同于直接插入排序)，也就是说，有序子序列中的所有元素的关键字一定小于(或大于)无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上。</li></ol><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>快速排序的基本思想是基于分治法的：在待排序表L[1…n]中任取一个元素pivot作为数轴(或称基准，通常取首元素)，通过一趟排序将待排序表划分成为独立的两部分L[1…K-1]和L[k+1…n],使得L[1…k-1]中所有元素小于pivot,L[k+1…n]中所有元素大于或等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至每部分内中只有一个元素或空为止，即所有元素放在了其最终位置上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(ElemType A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high&gt;)&#123;                                <span class="hljs-comment">//递归跳出的条件</span><br>    <span class="hljs-comment">// Partition()就是划分操作将表A[low...high]划分为满足上述条件的两个子表</span><br>        <span class="hljs-type">int</span> pivotpos = <span class="hljs-built_in">Partition</span>(A,low,high);       <span class="hljs-comment">//划分    </span><br>        <span class="hljs-built_in">QuickSort</span>(A,low,pivotpos - <span class="hljs-number">1</span>);              <span class="hljs-comment">//依次对两个子表进行递归排序</span><br>        <span class="hljs-built_in">QuickSort</span>(A,pivotpos + <span class="hljs-number">1</span>,high);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(ElemType A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;       <span class="hljs-comment">//一趟划分</span><br>    ElemType pivot = A[low];                        <span class="hljs-comment">//将当前表中第一个元素设为枢轴，对表进行划分</span><br>    <span class="hljs-keyword">while</span>(low &lt; high)&#123;                              <span class="hljs-comment">//循环跳出条件</span><br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) -- high;<br>        A[low] = A[high];                           <span class="hljs-comment">//将比枢轴小的元素移动到左端</span><br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot) ++ low;<br>        A[high] = A[low];                           <span class="hljs-comment">//将比枢轴大的元素移动到右端</span><br>    &#125;<br>    A[low] = pivot;                                 <span class="hljs-comment">//枢轴元素存放到最终位置</span><br>    <span class="hljs-keyword">return</span> low;                                     <span class="hljs-comment">//返回存放枢轴的最终位置</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><ol><li>空间效率：由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大深度一致。最好情况下为O(log<sub>2</sub><sup>n</sup>);最坏情况下，因为要进行n - 1次递归调用，所以栈的深度为O(n);平均情况下，栈的深度为O(log<sub>2</sub><sup>n</sup>)。</li><li>时间效率：快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含n - 1个元素和0个元素时，这种最大限度的不对称若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为O(log<sub>2</sub><sup>n</sup>)。<br>在理想状态下，即Partition()可能做到最平衡的划分，得到的两个子问题的大小都不可能大于n&#x2F;2，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为O(nlog<sub>2</sub><sup>n</sup>)。<br>※快速排序是所有内部排序算法中平均性能最优的排序算法。</li><li>稳定性：在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序方法。</li><li>最小递归次数 log<sub>2</sub><sup>n</sup> + 1 次<br>最大递归次数 n<br>时间复杂度 &#x3D; O(n * 递归层数)———— 最好—-&gt;nlog<sub>2</sub><sup>n</sup>   最坏—-&gt;n<sup>2</sup>.</li></ol><h3 id="习题总结"><a href="#习题总结" class="headerlink" title="习题总结"></a>习题总结</h3><ol><li>冒泡排序始终在调整“逆序”，因此交换次数为排列中逆序的个数。</li><li>当待排序数据为基本有序时，每次选取第n个元素为基准，会导致划分区间分配不均匀，不利于发挥快速排序算法的优势。相反，当待排序数据分布比较随机时，基准元素能将序列划分为两个长度大致相等的序列，这时才能发挥快速排序的优势</li><li>快速排序过程构成一个递归树，递归的深度即递归树的高度。枢轴值每次都将子表等分时，递归树的高度为log<sub>2</sub><sup>n</sup>；枢轴值每次都是子表的最大值或最小值时，递归树退化为单链表，树高为n。</li><li>采用递归方式对顺序表进行快速排序，递归的次数与个元素的初始排列有关。若每次划分后分区比较平衡，则递归次数少；若分区不平衡，递归次数多。递归次数与处理顺序是没有关系的。</li><li>快速排序空间复杂度只在最坏情况下才会达到O(n),平均情况下为O(log<sub>2</sub><sup>n</sup>)</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第八章 排序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/2023/05/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/05/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>基本思想是每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入。</li><li><img src="/2023/05/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/2023-05-10-16-55-15.png"><br>要将元素L[i]插入已有序的子序列L[1…i-1]，需要执行以下操作（L[]表示一个表，L()表示一个元素。<br>①查找出L(i)在L[1…i-1]中的插入位置k<br>②将L[k…i-1]中的所有元素依次后移一个位置。<br>③将L(i)复制到L(k)。</li></ol><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InserSort</span><span class="hljs-params">(ElemType A[],<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++)&#123;         <span class="hljs-comment">//依次将A[2]~A[n]插入前面已排序序列</span><br>        <span class="hljs-keyword">if</span>(A[i] &lt; A[i - <span class="hljs-number">1</span>])&#123;            <span class="hljs-comment">//若A[i]关键码小于前驱，将A[i]插入有序表</span><br>            A[<span class="hljs-number">0</span>] = A[i];                <span class="hljs-comment">//复制为哨兵，A[0]不存放元素</span><br>            <span class="hljs-keyword">for</span>(j = i - <span class="hljs-number">1</span>;A[<span class="hljs-number">0</span>] &lt; A[j];j --) <span class="hljs-comment">//从后往前查找待插入位置</span><br>                A[j + <span class="hljs-number">1</span>] = A[j];        <span class="hljs-comment">//向后挪位</span><br>            A[j + <span class="hljs-number">1</span>] = A[j];            <span class="hljs-comment">//复制到插入位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ol><li>空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1).</li><li>时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态<br>※ 在最好情况下，表中元素已经有序，此时每次插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为O(n)<br>※ 在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达到最大，总的移动次数也达到最大，总的时间复杂度为O(n<sup>2</sup>)<br>※ 因此，直接插入排序算法的时间复杂度为O(n<sup>2</sup>)\</li><li>稳定性：由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序方法\</li><li>适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。</li></ol><h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>在直接插入排序的基础上，将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。</li><li>当排序表为顺序表时，可以对直接插入排序做如下改进：由于是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素</li></ol><h3 id="模板代码-1"><a href="#模板代码-1" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InserSort</span><span class="hljs-params">(ElemType A[],<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j,low,high,mid;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>;i &lt;= n;i ++)&#123;                     <span class="hljs-comment">//依次将A[2]~A[n]插入到前面的已排序序列</span><br>        A[<span class="hljs-number">0</span>] = A[i];                            <span class="hljs-comment">//将A[i]暂存到A[0]</span><br>        low = <span class="hljs-number">1</span>;                                <span class="hljs-comment">//设置折半查找的范围</span><br>        high = i - <span class="hljs-number">1</span>;                           <span class="hljs-comment">//设置折半查找的范围</span><br>        <span class="hljs-keyword">while</span>(low &lt;= high)&#123;                     <span class="hljs-comment">//折半查找(默认递增有序)</span><br>            mid = (low + high) / <span class="hljs-number">2</span>;             <span class="hljs-comment">//取中间点</span><br>            <span class="hljs-keyword">if</span>(A[mid] &gt; A[<span class="hljs-number">0</span>]) high = mid - <span class="hljs-number">1</span>;   <span class="hljs-comment">//查找左半子表</span><br>            <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;                 <span class="hljs-comment">//查找右半子表</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(j = i - <span class="hljs-number">1</span>;j &gt;= high + <span class="hljs-number">1</span>;-- j)<br>        A[j + <span class="hljs-number">1</span>] = A[j];                        <span class="hljs-comment">//统一后移元素，空出插入位置</span><br>        A[high + <span class="hljs-number">1</span>] = A[<span class="hljs-number">0</span>];                     <span class="hljs-comment">//插入操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><ol><li>比较次数：不难看出，折半插入排序仅减少了比较元素的次数，约为O(nlog<sub>2</sub><sup>n</sup>),该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n,而元素的移动次数并未发生改变，她依赖于待排序表的初始状态</li><li>时间复杂度：O(n<sup>2</sup>),对于数据量不是很大的排序表，折半插入排序往往能表现出很好的性能。</li><li>稳定性：折半插入排序是一种稳定的排序方法。</li></ol><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>先将待排序表分割成若干形如L[i,i+di+2d,…,i+kd]的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。</p><h3 id="模板代码-2"><a href="#模板代码-2" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(ElemType A[],<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//A[0]只是暂存单元，不是哨兵，当j &lt;= 0 时，插入位置已到</span><br>    <span class="hljs-type">int</span> dk,i,j;<br>    <span class="hljs-keyword">for</span>(dk = n / <span class="hljs-number">2</span>;dk &gt;= <span class="hljs-number">1</span>;dk = dk / <span class="hljs-number">2</span>)                             <span class="hljs-comment">//增量变化（无统一规定）</span><br>        <span class="hljs-keyword">for</span>(i = dk + <span class="hljs-number">1</span>;i &lt;= n;++ i)<br>            <span class="hljs-keyword">if</span>(A[i] &lt; A[i - dk])&#123;                                   <span class="hljs-comment">//需将A[i]插入有序增量子表</span><br>                A[<span class="hljs-number">0</span>] = A[i];                                        <span class="hljs-comment">//暂存在A[0]        </span><br>                <span class="hljs-keyword">for</span>(j = i - dk;j &gt; <span class="hljs-number">0</span> &amp;&amp; A[<span class="hljs-number">0</span>] &lt; A[j];j -= dk)<br>                    A[j + dk] = A[j];                               <span class="hljs-comment">//记录后移，查找插入的位置</span><br>                A[j + dk] = A[<span class="hljs-number">0</span>];                                   <span class="hljs-comment">//插入</span><br>            &#125;<span class="hljs-comment">//if</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><ol><li>空间效率：仅使用常数个辅助单元，因而空间复杂度为O(1)。</li><li>时间效率：由于希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当n在某个特定范围时，希尔排序的时间复杂度为O(n<sup>1.3</sup>)。在最坏情况下希尔排序的时间复杂度为O(n<sup>2</sup>)。</li><li>稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变他们之间的相对次序，因此希尔排序是一种不稳定的排序方法。</li><li>适用性：希尔排序算法仅适用于线性表为顺序存储的情况。</li></ol><h2 id="习题总结"><a href="#习题总结" class="headerlink" title="习题总结"></a>习题总结</h2><ol><li>直接插入排序在最坏的情况下要做n(n - 1 ) &#x2F; 2 次关键字的比较。(不考虑于哨兵的比较)</li><li>在待排序的元素序列基本有序的前提下，效率最高的排序方法是(A)<br>A. 直接插入排序  B. 简单选择排序  C. 快速排序  D. 归并排序<br>※ 由于这里的序列基本有序，使用直接插入排序算法的时间复杂度接近O(n)，而使用其他算法的时间复杂度均大于O(n)。</li><li>对n个元素的顺序表采用直接插入排序算法进行排序，在最坏情况下所需的比较次数是( n(n - 1) &#x2F; 2); 在最好情况下所需的比较次数是( n - 1)。</li><li>※ 在排序过程中，每趟能确定一个元素在其最终位置的有冒泡排序、简单选择排序、堆排序、快速排序，其中前三者能形成全局有序的子序列，后者能确定枢轴元素的最终位置。</li><li>在直接插入排序中，若待排序列中的最后一个元素应插入表中的第一个位置，则前面的有序子序列中的所有元素都不在最终的位置上</li><li>希尔排序是对直接排序算法改进后提出来的，本质上仍属于插入排序的范围。</li><li>虽然折半插入排序是对直接插入排序的改进，但它改进的只是比较的次数，而移动次数并未发生变化，时间复杂度仍为O(n<sup>2</sup>)。</li><li>基于插入、交换、选择的三类排序方法中，通常简单方法是稳定的(直接插入、折半插入、冒泡、归并),但有一个例外就是简单选择，复杂方法都是不稳定的(希尔、快排、堆排)。</li><li>每趟冒泡和选择排序后，总会有一个元素被放置在最终位置上、2路归并算法经过第二趟后应该是每4个元素是有序的</li><li>折半插入排序的比较次数与初始序列初态无关，为O(nlog<sub>2</sub><sup>n</sup>)。而直接插入排序的比较次数与序列初态有关，为O(n)~O(n<sup>2</sup>)。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第八章 排序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/05/06/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/05/06/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Trie</title>
    <link href="/2023/05/06/Trie/"/>
    <url>/2023/05/06/Trie/</url>
    
    <content type="html"><![CDATA[<h1 id="Trie数"><a href="#Trie数" class="headerlink" title="Trie数"></a>Trie数</h1><h2 id="Tire树介绍"><a href="#Tire树介绍" class="headerlink" title="Tire树介绍"></a>Tire树介绍</h2><ol><li>Tire 树 又称单词查找树，是一种树形结构，是一种哈希树的变种。</li><li>Tire 树是一种能够快速存储和查找一组字符串集合的数据结构，是以空间换时间，利用字符串的前缀来降低查询时间。</li><li>与二叉树不同，Tire 树有 26 子节点对应 26 个字母，根节点不包含字符串，从根节点到某个节点，经过的字符连起来的字符串就是对应的字符串。当储存结束一个字符串后，尾节点会产生一个标记，表示当前字符串已经结束了。</li><li>典型应用：用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</li><li>如下图就是一棵由字符串 abcdef，abdef，aced，bcdf，bcfc，bcff，cdaa，组成的 Tire 树：<br><img src="/2023/05/06/Trie/2023-05-06-20-26-24.png"></li></ol><h2 id="优缺点及性质"><a href="#优缺点及性质" class="headerlink" title="优缺点及性质"></a>优缺点及性质</h2><ol><li>优点：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</li><li>缺点：空间复杂度比较大。</li><li>优化：我们可以用链表来动态开辟空间，达到空间上利用率的最大化。</li><li>性质：</li></ol><p>（1）根结点不包含字符，其他的每一个节点只包含一个字符。</p><p>（2）从根结点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串（假如某个节点为一个字符串的结尾，对其打个标记即可）。</p><p>（3）每个节点的所有子节点包含的字符都不相同。</p><h2 id="Tire树例题—-gt-Tire字符串统计"><a href="#Tire树例题—-gt-Tire字符串统计" class="headerlink" title="Tire树例题—-&gt;Tire字符串统计"></a>Tire树例题—-&gt;Tire字符串统计</h2><p><img src="/2023/05/06/Trie/2023-05-06-20-30-33.png"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>],cnt[N],idx;      <span class="hljs-comment">//son[N][26]:储存子节点的位置，分支最多26条,cnt[N]表示以当前这个点结尾的单词有多少个，idx表示当前用到了哪个下标，下标是0的点，既是根节点，又是空节点</span><br><span class="hljs-type">char</span> str[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;      <span class="hljs-comment">//从根节点出发</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;str[i];i ++)&#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;           <span class="hljs-comment">//当前节点是什么字符</span><br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++ idx;  <span class="hljs-comment">//如果节点不存在就新建节点</span><br>        p = son[p][u];      <span class="hljs-comment">//p指向新建的节点</span><br>    &#125;<br>    cnt[p] ++;      <span class="hljs-comment">//表示以这个字母结尾的单词增加了一个</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span>&#123;<br>    <span class="hljs-type">int</span> p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;str[i];i ++)&#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u])  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">//该节点不存在，即该字符串不存在</span><br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];      <span class="hljs-comment">//返回字符串出现的次数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n -- )&#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,op,str);<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>) <span class="hljs-built_in">insert</span>(str);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">query</span>(str));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Tire树例题—–-gt-最大异或对"><a href="#Tire树例题—–-gt-最大异或对" class="headerlink" title="Tire树例题—–&gt;最大异或对"></a>Tire树例题—–&gt;最大异或对</h2><p><img src="/2023/05/06/Trie/2023-05-06-20-32-45.png"></p><h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><ol><li>暴力做法通俗易懂，两个 for 循环，相互枚举每一个值，异或，最后答案为其中的最大值。</li><li>暴力做法虽然易做，但是会出现 超时 问题。</li></ol><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>&#123;<br>res=<span class="hljs-built_in">max</span>(res,a[i]^a[j]);<br>&#125;<br>&#125;<br>cout&lt;&lt;res&lt;&lt;endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>); <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优美解法"><a href="#优美解法" class="headerlink" title="优美解法"></a>优美解法</h3><ol><li>首先，需要搞清楚 异或操作。</li><li>如果 A &#x3D; 1101 ，B &#x3D; 0111，那么 A ^ B &#x3D; 1010。详细讲解请见 基础算法-位运算</li><li>对暴力做法进行优化，使其满足时间限制。</li><li>由异或操作的计算公式可知，我们只需要先遍历每一个数，然后根据遍历的数的对应二进制形式，选取一个尽可能二进制形式每一位都不同的数字，得到该数字的最大异或值，最后再选举最大的异或值。在得到每一个数字的最大亦或值的选取过程就是一个 Tire 数。</li><li>举例说明：<br><img src="/2023/05/06/Trie/2023-05-06-20-35-56.png"></li></ol><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">3100010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], son[M][<span class="hljs-number">2</span>], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-type">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (!s) <br>        &#123;<br>            idx ++;<br>            s = idx;<br>        &#125;<br>        p = s;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-type">int</span> s = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (son[p][!s])<br>        &#123;<br>            res += <span class="hljs-number">1</span> &lt;&lt; i;<br>            p = son[p][!s];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            p = son[p][s];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        cin &gt;&gt; a[i];<br>        <span class="hljs-built_in">insert</span>(a[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">search</span>(a[i]));<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法基础,第二章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/2023/05/06/KMP/"/>
    <url>/2023/05/06/KMP/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//KMP</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>,M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">char</span> p[N],s[M];<br><span class="hljs-type">int</span> ne[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; s + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//求next的过程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>,j = <span class="hljs-number">0</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>]) j ++;<br>        ne[i] = j;<br>    &#125;<br><br>    <span class="hljs-comment">//KMP匹配过程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>,j = <span class="hljs-number">0</span>;i &lt;= m;i ++)&#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span>(s[i] == p[j + <span class="hljs-number">1</span>]) j ++;<br>        <span class="hljs-keyword">if</span>(j == n)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i - n);<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列：单调队列、单调栈</title>
    <link href="/2023/05/04/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%EF%BC%9A%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E3%80%81%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2023/05/04/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%EF%BC%9A%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E3%80%81%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="栈与队列：单调队列、单调栈"><a href="#栈与队列：单调队列、单调栈" class="headerlink" title="栈与队列：单调队列、单调栈"></a>栈与队列：单调队列、单调栈</h1><h2 id="栈和队列的基本操作"><a href="#栈和队列的基本操作" class="headerlink" title="栈和队列的基本操作"></a>栈和队列的基本操作</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>栈：先进后出</li><li>队列：先进先出</li></ol><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> +<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> stk[N],tt = <span class="hljs-number">0</span>;          <span class="hljs-comment">//tt表示栈顶下标,初始时为0</span><br><span class="hljs-comment">// ********************** 栈</span><br><span class="hljs-comment">//插入</span><br>stk[ ++ tt] = x;<br><br><span class="hljs-comment">//弹出</span><br>tt --;<br><br><span class="hljs-comment">//判断栈是否为空</span><br><span class="hljs-keyword">if</span>(tt &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">not</span> empty<br><span class="hljs-keyword">else</span> empty<br><br><span class="hljs-comment">//栈顶</span><br>stk[tt];<br><span class="hljs-comment">// ********************** 队列</span><br><span class="hljs-comment">//队尾插入元素，队头弹出元素</span><br><span class="hljs-type">int</span> q[N],hh,tt = <span class="hljs-number">-1</span>;         <span class="hljs-comment">//hh表示队头，tt表示队尾初始时为-1</span><br><br><span class="hljs-comment">//插入</span><br>q[++ tt] = x;<br><br><span class="hljs-comment">//弹出</span><br>hh ++;<br><br><span class="hljs-comment">//判断队列是否为空</span><br><span class="hljs-keyword">if</span>(hh &lt;= tt) <span class="hljs-keyword">not</span> empty<br><span class="hljs-keyword">else</span> empty<br><br><span class="hljs-comment">//取出队头元素</span><br>q[hh];<br><br></code></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ol><li>给定一个序列，求出在这个序列当中，每一个数离他左边最近的数且比它小的数在什么地方，不存在返回-1   </li><li>单调递增栈： 从栈顶往栈底看，是单调递增的关系（含相等）</li><li>单调递减栈： 从栈顶往栈底看，是单调递减的关系（含相等）</li><li><img src="/2023/05/04/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%EF%BC%9A%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E3%80%81%E5%8D%95%E8%B0%83%E6%A0%88/2023-05-05-11-22-41.png"></li></ol><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//单调栈</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> stk[N],tt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= x) tt --;<br>        <span class="hljs-keyword">if</span>(tt) cout &lt;&lt; stk[tt] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        stk[++ tt] = x;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最小值</li></ol><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//单调队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[N],q[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>,tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        <span class="hljs-comment">//判断队头是否已经滑出窗口</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh])  hh ++;<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --;<br>        q[++ tt] = i;<br>        <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[q[hh]]);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    hh = <span class="hljs-number">0</span>,tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        <span class="hljs-comment">//判断队头是否已经滑出窗口</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh])  hh ++;<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt --;<br>        q[++ tt] = i;<br>        <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[q[hh]]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表与邻接表：树与图的存储</title>
    <link href="/2023/05/04/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%9A%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <url>/2023/05/04/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%9A%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表与邻接表：树与图的存储（用数组模拟）"><a href="#链表与邻接表：树与图的存储（用数组模拟）" class="headerlink" title="链表与邻接表：树与图的存储（用数组模拟）"></a>链表与邻接表：树与图的存储（用数组模拟）</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="算法思想（静态链表）"><a href="#算法思想（静态链表）" class="headerlink" title="算法思想（静态链表）"></a>算法思想（静态链表）</h3><ol><li>用数组模拟效率高，以为如果用结构体的话，每次要new一个节点，这样会很慢</li><li>单链表–&gt;邻接表–&gt;存储树和图</li><li>双链表–&gt;用来优化某些题目</li><li>刚开始设置头结点head为空</li><li>数组表示链表，e[N]为节点存储的值，ne[N]节点指向的下一个节点，空节点的下标用-1表示<br><img src="/2023/05/04/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%9A%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/2023-05-04-16-48-25.png"></li></ol><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//head表示头结点的下标</span><br><span class="hljs-comment">//e[i]表示节点i的值</span><br><span class="hljs-comment">//ne[i]表示节点i的next指针是多少</span><br><span class="hljs-comment">//idx 存储当前已经用到了哪个点</span><br><br><span class="hljs-type">int</span> head,e[N],ne[N],idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//将x插入头结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = head;<br>    head = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-comment">//将x插入到下标是k的节点的后面</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = ne[k];<br>    ne[k] = idx;<br>    idx ++;<br>&#125;<br><br><span class="hljs-comment">//将下标是k的节点的下一个节点删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    ne[k] = ne[ne[k]];      <span class="hljs-comment">//算法中不需要管释放空间的问题</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> k,x;<br>        <span class="hljs-type">char</span> op;<br><br>        cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">add_to_head</span>(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>            cin &gt;&gt; k;<br>            <span class="hljs-keyword">if</span>( !k ) head = ne[head];<br>            <span class="hljs-built_in">remove</span>(k - <span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cin &gt;&gt; k &gt;&gt; x;<br>            <span class="hljs-built_in">add</span>(k - <span class="hljs-number">1</span>,x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head;i != <span class="hljs-number">-1</span>;i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>与单链表类似，只是多了一个指向左边的数组，初始化不一样而已。</p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//双链表</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> m;<br><span class="hljs-type">int</span> e[N],l[N],r[N],idx;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//0表示左端点，1表示右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>,l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">//在下标是k的点的右边插入x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;  <span class="hljs-comment">//在下表为k的点的左边插入一个点，调用函数add(l[k],x)即可</span><br>    e[idx] = x;<br>    r[idx] = r[k];<br>    l[idx] = k;<br>    l[r[k]] = idx;      <span class="hljs-comment">//此操作一定在r[k] = idx 之前</span><br>    r[k] = idx;<br>&#125;<br><br><span class="hljs-comment">//删除下表为k的点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章Tag文件与Tag标记</title>
    <link href="/2023/05/04/JSP%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2023/05/04/JSP%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章Tag文件与Tag标记"><a href="#第三章Tag文件与Tag标记" class="headerlink" title="第三章Tag文件与Tag标记"></a>第三章Tag文件与Tag标记</h1><h2 id="3-1Tag文件"><a href="#3-1Tag文件" class="headerlink" title="3.1Tag文件"></a>3.1Tag文件</h2><h3 id="3-1-1Tag文件的结构"><a href="#3-1-1Tag文件的结构" class="headerlink" title="3.1.1Tag文件的结构"></a>3.1.1Tag文件的结构</h3><p>Tag文件是扩展名为.tag的文本文件，其结构和JSP文件类似。其中可以有普通的HTML标记符、某些特殊的指令标记、成员变量声明和方法的定义。Java程序片和Java表达式。</p><h3 id="3-1-2Tag文件的保存"><a href="#3-1-2Tag文件的保存" class="headerlink" title="3.1.2Tag文件的保存"></a>3.1.2Tag文件的保存</h3><p>1.Tag文件所在目录</p><p>在 JSP 中，标签文件通常存储在 WEB-INF&#x2F;tags 目录下，该目录是受保护的，无法从客户端（即浏览器）访问。标签文件应该放在具有描述性子目录名称的目录下，例如：WEB-INF&#x2F;tags&#x2F;forms 或 WEB-INF&#x2F;tags&#x2F;utilities。这样会使您的标签更易于组织和查找。</p><p>2.Tag文件的编码</p><p>在 JSP 标签文件中使用的编码方式与常规的 JSP 页面相同。您可以指定 JSP 标签文件的编码方式，例如 UTF-8，通过在 JSP 标签文件的开始标记 &lt;%@ tag %&gt; 中添加 charset 属性。例如：</p><p>&lt;%@ tag language&#x3D;”java” pageEncoding&#x3D;”UTF-8” %&gt;<br>注意：在 JSP 标签文件的开始标记中使用 pageEncoding 属性指定编码方式只是一种指定编码的方式。确保在编辑标签文件时使用相同的编码方式。</p><h2 id="3-2Tag标记"><a href="#3-2Tag标记" class="headerlink" title="3.2Tag标记"></a>3.2Tag标记</h2><h3 id="3-2-1"><a href="#3-2-1" class="headerlink" title="3.2.1"></a>3.2.1</h3><p>在 JSP 中，标签（Tag）和标签文件（Tag file）是不同的概念。 标签是用于在 JSP 页面中引用自定义的 Java 代码的一种机制。JSP 标签包含正文和属性，可用于在 JSP 中重复使用Java 代码块。标签通常用于实现页面布局、处理表单、执行业务逻辑等操作。标签的使用方式类似于 HTML 标签，但标签的实现通常是基于 Java 类、接口和配置文件。 而标签文件（Tag file）是一种用于创建 JSP 标签的机制。标签文件包含 JSP 代码和 Java 代码，可以用于定义与标签相关的行为和逻辑。标签文件本质上是一个 JSP 网页，但是它不是在浏览器中运行，而是在 JSP 引擎中执行。使用标签文件可以使 JSP 页面更易于组织和维护。 为了使用标签文件，我们需要： 1. 创建一个标签文件，这可以是一个 JSP 文件，其中包含标签的实现代码，或者是一个 JSPF（JSP Fragment）文件，其中只包含标签的实现代码。 2. 在标签文件中定义所需的属性和标签正文。 3. 在 JSP 页面中使用类似于 HTML 标签的方式来调用标签。 4. 在 JSP 页面的声明部分中导入标签库并指定标签文件的路径。 例如，以下代码演示了在 JSP 页面中如何使用自定义的标签：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JSP">&lt;%@ taglib prefix=<span class="hljs-string">&quot;myTag&quot;</span> uri=<span class="hljs-string">&quot;/WEB-INF/tags/myTag.tag&quot;</span> %&gt;<br>&lt;myTag:helloWorld name=<span class="hljs-string">&quot;John&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>其中，标签库前缀（prefix）是 myTag，标签文件的路径（uri）是 &#x2F;WEB-INF&#x2F;tags&#x2F;myTag.tag，name 属性的值是 John。在这个例子中，我们将所有的自定义标签存储在标签文件 myTag.tag 中，该文件位于 WEB-INF&#x2F;tags 目录下。</p><h3 id="3-2-2"><a href="#3-2-2" class="headerlink" title="3.2.2"></a>3.2.2</h3><p>在 JSP 中，可以使用自定义的标签（Tag）来组织和重用页面。自定义标签可以看做是用于替代 Java 代码的高层次的组合元素。标签可以执行各种任务，例如： - 根据参数传递数据 - 控制页面流程 - 实现业务逻辑 - 处理表单数据 - 生成 HTML 或其他格式的文本 在 JSP 中使用标签包括两个部分： 1. 定义标签的实现 在 JSP 中定义标签的实现通常使用 Java 类和配置文件。Java 类实现标签的具体逻辑和行为，配置文件定义标签的属性、方法和行为。标签的实现通常存储在 WEB-INF&#x2F;classes 或 WEB-INF&#x2F;lib 目录中。 以下是一个自定义标签的实现示例：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JSP"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloTag</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TagSupport</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doStartTag</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JspException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">JspWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> pageContext.getOut();<br>            out.write(<span class="hljs-string">&quot;&lt;h1&gt;Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&lt;/h1&gt;&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JspException</span>(<span class="hljs-string">&quot;Error: &quot;</span> + e.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">return</span> SKIP_BODY;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用 TagSupport 类作为基类，并实现了 doStartTag() 方法来生成 HTML 消息。在标签实现类中，我们还定义了标签的属性 name。 2. 使用自定义标签 在 JSP 页面中使用自定义标签需要以下步骤： - 在 JSP 页面的顶部导入标签库，例如：&lt;%@taglib prefix&#x3D;”mytag” uri&#x3D;”&#x2F;WEB-INF&#x2F;tags&#x2F;mytag.tld”%&gt;。 - 在需要使用标签的位置插入标签代码，例如：&lt;mytag:hello name&#x3D;”John” &#x2F;&gt;。 在这个例子中，我们将自定义标签库的前缀设置为 mytag，标签库的 URI 是 &#x2F;WEB-INF&#x2F;tags&#x2F;mytag.tld。我们还使用自定义标签生成了一个简单的 HTML 消息，其属性 name 的值是 John。 以上是自定义标签在 JSP 中的基本用法。使用标签可以大大简化 JSP 页面的开发和维护，提高代码的重用性和可读性。</p><h3 id="3-2-3"><a href="#3-2-3" class="headerlink" title="3.2.3"></a>3.2.3</h3><p>在 JSP 中，标签（Tag）是一个类似于 HTML 标签的元素，可以用于编写可重用的 Java 代码。标签在 JSP 引擎中运行时，会被解析成 Java 代码，并与页面的其他部分一起编译成一个 Servlet。在客户端访问 JSP 页面时，Servlet 会根据请求生成响应并发送给客户端。 自定义标签的运行原理如下： 1. 标签解析 当 JSP 引擎遇到自定义标签时，会首先解析标签的定义，并根据标签定义生成相应的 Java 代码。标签定义可以包括标签的属性、行为和逻辑，以及标签的处理类和配置文件等。 2. 标签处理 一旦标签被解析，标签处理类就会被实例化，并在页面的运行时环境中执行。标签的属性值会被传递给标签处理类，并在标签处理类中进行相应的处理。此过程中产生的任何输出都会传递给 JSP 引擎，最终被合并到页面的其他部分中。 3. 页面生成 在 JSP 引擎结束处理标签后，它将合并标签处理类产生的任何输出，并将其与页面的其他部分一起编译成一个 Servlet。在客户端访问 JSP 页面时，Servlet 会根据请求生成响应并发送给客户端。 简而言之，JSP 标签的运行原理基于标签的解析、标签处理和页面生成。标签的解析和处理是在服务器端完成的，可以让开发人员编写更加简洁、可重用的代码。这样可以提高开发效率和代码的可读性，同时也可以减少代码的重复编写。</p><h2 id="3-3Tag文件中的常用指令"><a href="#3-3Tag文件中的常用指令" class="headerlink" title="3.3Tag文件中的常用指令"></a>3.3Tag文件中的常用指令</h2><h3 id="3-3-1Tag指令"><a href="#3-3-1Tag指令" class="headerlink" title="3.3.1Tag指令"></a>3.3.1Tag指令</h3><p>tag指令</p><p>&lt;%@ tag %&gt; 此 JSP 指令用于声明自定义标记的页面特定属性。它位于 JSP 页面的顶部，在任何 HTML 或 Java 代码之前，用于定义标记的属性和特征。这些属性可以包括标记名称、标记正文内容、属性名称和类型等内容。</p><h3 id="3-3-2-include指令"><a href="#3-3-2-include指令" class="headerlink" title="3.3.2 include指令"></a>3.3.2 include指令</h3><p>在Tag文件中也有和JSP文件类似的include指令标记，其使用方法和作用与JSP文件中的include指令类似。</p><h3 id="3-3-3-arrtibute指令"><a href="#3-3-3-arrtibute指令" class="headerlink" title="3.3.3 arrtibute指令"></a>3.3.3 arrtibute指令</h3><p>在Tag文件中通过使用attribute指令让使用它的JSP页面向该Tag文件传递需要的数据。attribute指令的格式如下：</p><p>&lt;%@ attribute name &#x3D;”对象名字”required&#x3D;”true”|”false” type&#x3D;”对象的类型”%&gt;<br> 例如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ <span class="hljs-type">attribute</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;result&quot;</span>required=<span class="hljs-string">&quot;true&quot;</span> type=<span class="hljs-string">&quot;java.long.Double&quot;</span>%&gt;<br></code></pre></td></tr></table></figure><p>就相当于Tag文件中有了一个名字是result的对象，但Tag文件不需要创建该对象的result，而是等待JSP页面将一个Double型的对象的引用传递给result。 </p><p>JSP页面使用Tag标记向所调用的Tag文件中name指定的对象传递一个引用，方式如下</p><p>&lt;前缀：Tag文件名字 对象名字&#x3D;”对象的引用”&#x2F;&gt;<br> 比如，JSP页面使用Tag标记（假设尿急浅醉为computer）调用myTag.tag:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;computer:<span class="hljs-type">myTag</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;new Double(3.1415926)&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="3-3-4-variable指令"><a href="#3-3-4-variable指令" class="headerlink" title="3.3.4 variable指令"></a>3.3.4 variable指令</h3><p>Tag文件通过使用variable指令可以将Tag文件中的对象返回给调用该Tag文件的JSP页面</p><p>variable指令格式如下：</p><p>&lt;%@ variable name-given&#x3D;”对象名”variable-class&#x3D;”对象类型”scope&#x3D;”有效范围”%&gt;<br>Tag文件为了给JSP页面返回一个对象，就必须将返回的对象的名字以及该对象的引用储存到Tomcat服务器提供的内置对象jspContext中，比如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ variable name-given=<span class="hljs-string">&quot;time&quot;</span><br>    variable-class=<span class="hljs-string">&quot;java.time.LocalDate&quot;</span>scop=AT_END<span class="hljs-string">&quot;%&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>双指针算法</title>
    <link href="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-24-17-57-13.png"></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>输入一行字串如“abc def ghi” <br>将单词输出即<br>abc<br>def<br>ghi<br>※思路，定义两个指针，i指向第一个单词，j向后扫描，如果扫到’ ‘空格就停下来，然后输出i到j-1包含的单词，然后使i &#x3D; j进入下一层循环。\</p><h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">gets</span>(str);<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; str[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i;k &lt; j;k ++) cout &lt;&lt; str[k];<br>        cout &lt;&lt; endl;<br>        i = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h2><p><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-24-19-08-58.png"></p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-24-19-03-51.png"><br>※每次都枚举i,j从0开始。<br>※用s[]数组记录当前[j,i]中数的个数，当i前移时时s[a[i]]++，当s[a[i]] &gt; 1时，说明区间内有重复的数，则让s[a[j]]–，然后使j往前移动，重复上述操作。<br>※不重复序列的长度res &#x3D; max(res,i - j + 1)，因为i比j大</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        s[a[i]] ++;<br>        <span class="hljs-keyword">while</span>(s[a[i]] &gt; <span class="hljs-number">1</span>)&#123;<br>            s[a[j]] --;<br>            j++;<br>        &#125;<br>        res = <span class="hljs-built_in">max</span>(res,i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="求n的二进制表示中的第k位数字"><a href="#求n的二进制表示中的第k位数字" class="headerlink" title="求n的二进制表示中的第k位数字"></a>求n的二进制表示中的第k位数字</h3><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>※求n的二进制表示中的第k位数字：n &gt;&gt; k &amp; 1</p><p>①先把第k位移到最后一位：n &gt;&gt; k;</p><p>②看个位是几:           x &amp; 1</p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//n的二进制表示中的第k位数字</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">3</span>;k &gt;= <span class="hljs-number">0</span>;k --)  cout &lt;&lt; (n &gt;&gt; k &amp; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="返回n的最后一位1"><a href="#返回n的最后一位1" class="headerlink" title="返回n的最后一位1"></a>返回n的最后一位1</h2><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>※返回n的最后一位1：lowbit(n) -&gt; n &amp; - n<br><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-24-19-49-36.png"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-24-19-52-00.png"></p><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//二进制数中1的个数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;                              <span class="hljs-comment">//进行n次查询</span><br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n  --)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;                       <span class="hljs-comment">//要查询的数x</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x) x -= <span class="hljs-built_in">lowbit</span>(x),res ++ ; <span class="hljs-comment">//每次减去x的最后一个1</span><br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-26-19-22-00.png"><br>※加1的话，从1开始映射，不加1的话，从0开始映射</p><h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-26-19-23-59.png"><br>1.介绍</p><p>离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。离散化本质上可以看成是一种哈希。<br>2.算法<br><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-26-19-17-22.png"><br>※unique函数是将数组中所有元素去重，返回去重之后数组的尾端点，使用unique函数必须先排序。<br>※erase函数是删除unique函数返回的尾端点与数组尾端点的值，也就是删除重复元素</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-26-19-26-31.png"></p><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//离散化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n ,m;<br><span class="hljs-type">int</span> a[N],s[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;      <br><br>vector&lt;<span class="hljs-type">int</span>&gt; alls;       <span class="hljs-comment">//存的所要离散化的元素</span><br>vector&lt;PII&gt; add,query; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        <span class="hljs-type">int</span> x,c;<br>        cin &gt;&gt; x &gt;&gt; c;<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x, c&#125;);<br>        alls.<span class="hljs-built_in">push_back</span>(x);          <span class="hljs-comment">//将x加入到待离散化的数组里面去</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i ++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        query.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);<br>        alls.<span class="hljs-built_in">push_back</span>(l);          <span class="hljs-comment">//将左区间加入到待离散化的数组里面去</span><br>        alls.<span class="hljs-built_in">push_back</span>(r);          <span class="hljs-comment">//将右区间加入到待离散化的数组里面去</span><br>    &#125;<br><br>    <span class="hljs-comment">//去重</span><br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());      <span class="hljs-comment">//先排序</span><br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());     <span class="hljs-comment">//去掉重复元素</span><br>    <br>    <span class="hljs-comment">//处理插入</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : add)&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(item.first);   <span class="hljs-comment">//item.first相当与x</span><br>        a[x] += item.second;        <span class="hljs-comment">//在离散化后的位置加上要加的数  item.second相当于c</span><br>    &#125;<br>   <br>    <span class="hljs-comment">//处理前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= alls.<span class="hljs-built_in">size</span>();i ++) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>  <br>    <span class="hljs-comment">//处理查询</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : query)&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(item.first), r = <span class="hljs-built_in">find</span>(item.second);<br>        cout &lt;&lt; s[r] - s[l - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><p><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-26-20-05-30.png"></p><h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><p>※图解<br><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-26-20-08-35.png"><br>1.按区间左端点排序<br>2.扫描整个区间，扫描过程中，把所有可能有交集的区间进行合并<br><img src="/2023/04/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/2023-04-26-20-41-24.png"></p><h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//区间合并</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n ;<br>vector&lt;PII&gt; segs;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span>&#123;<br>    vector&lt;PII&gt; res;<br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(),segs.<span class="hljs-built_in">end</span>());      <span class="hljs-comment">//对pari，优先以左端点排序，再以右端点排序</span><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>,ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> seg:segs)&#123;<br>        <span class="hljs-keyword">if</span>(ed &lt; seg.first)&#123;<br>            <span class="hljs-keyword">if</span>(st != <span class="hljs-number">-2e9</span>)<br>                res.<span class="hljs-built_in">push_back</span>(&#123;st,ed&#125;);<br>            st = seg.first,ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            ed = <span class="hljs-built_in">max</span>(ed,seg.second);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st,ed&#125;);<br>    segs = res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        segs.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>    &#125;<br><br>    <span class="hljs-built_in">merge</span>(segs);<br>    cout &lt;&lt; segs.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一次习题课</title>
    <link href="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    <url>/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="第K个数-快速选择"><a href="#第K个数-快速选择" class="headerlink" title="第K个数(快速选择)"></a>第K个数(快速选择)</h1><p><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-23-21-50-37.png"></p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>🔺快排思想<br>※找到分界点x，q[l],q[(l + r) &gt;&gt; 1],q[r].<br>※左边所有数Left &lt;&#x3D; x,右边所有数Right &gt;&#x3D; x.<br>※递归排序Left，递归排序Right<br>🔺快选思想<br>※找到分界点x，q[l],q[(l + r) &gt;&gt; 1],q[r].<br>※左边所有数Left &lt;&#x3D; x,右边所有数Right &gt;&#x3D; x.<br>※统计x左边所有数的个数S<sub>l</sub>,和右边所有数的个数S<sub>r</sub>.<br>※①当K &lt;&#x3D; S<sub>l</sub>时，则递归左边区间 要查找的个数为S<sub>l</sub><br>※②当K &gt; S<sub>l</sub>时，则递归右边区间 要查找的个数应变为K -  S<sub>l</sub><br>※时间复杂度o(n).</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;      <span class="hljs-comment">//C++中，局部变量与全局变量重名时，优先使用局部变量</span><br>    <span class="hljs-keyword">if</span> (l == r)                         <span class="hljs-comment">//快排里面必须写&gt;=,而快选2个均可</span><br>        <span class="hljs-keyword">return</span> q[l];                    <span class="hljs-comment">//当递归只剩一个数时，则是要查找的数</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>,j = r + <span class="hljs-number">1</span>,x = q[l];<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span> i ++;<span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j --;<span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;     <span class="hljs-comment">//左半边区间是[l,j]，右半区间是[j+1,r],所以sl = j - l + 1;</span><br>    <span class="hljs-keyword">if</span>(k &lt;= sl) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(l,j,k);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(j+<span class="hljs-number">1</span>,r,k-sl);      <span class="hljs-comment">//整个区间第K小个数，相当于是右半区间第K-sl小个数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    cout &lt;&lt; <span class="hljs-built_in">quick_sort</span>(<span class="hljs-number">0</span>,n - <span class="hljs-number">1</span>,k) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="逆序对的数量"><a href="#逆序对的数量" class="headerlink" title="逆序对的数量"></a>逆序对的数量</h1><p><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-23-21-51-15.png"></p><h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>🔺归并排序思想<br>※[L,R] &#x3D;&gt; 分为[L,mid],[mid + 1,R]<br>※递归排序[L,mid]和[mid + 1,R]<br>※归并，将左右两个有序序列合并成一个有序序列<br><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-23-21-51-39.png"></p><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//逆序对的数量</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],temp[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function">LL <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    LL res = <span class="hljs-built_in">merge_sort</span>(l,mid) + <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>,i = l,j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])     temp[k ++] = q[i ++];<br>        <span class="hljs-keyword">else</span> &#123;<br>            temp[k ++] = q[j ++];<br>            res += mid - i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) temp[k ++] = q[i ++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) temp[k ++] = q[j ++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l,j = <span class="hljs-number">0</span>;i &lt;= r;i++,j++)&#123;<br>        q[i] = temp [j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    cout &lt;&lt; <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>,n - <span class="hljs-number">1</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数的三次方根"><a href="#数的三次方根" class="headerlink" title="数的三次方根"></a>数的三次方根</h1><p><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-23-22-57-45.png"></p><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><p>与浮点二分一样 只是判断条件不同而已。</p><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//求数的三次方根</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> x;<br>    cin &gt;&gt; x;<br>    <span class="hljs-type">double</span> l = <span class="hljs-number">-10000</span>,r = <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">while</span>(r - l &gt; <span class="hljs-number">1e-8</span>)&#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span> ;<br>        <span class="hljs-keyword">if</span>(mid * mid * mid &gt;=x)  r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-23-23-18-27.png"><br><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-23-23-19-58.png"></p><h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><p>与一维前缀和算法一致</p><h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//前缀和</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],S[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) S[i] = S[i - <span class="hljs-number">1</span>] + a[i];<br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,S[r]-S[l - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h1><p><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-24-16-05-54.png"></p><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><p><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-24-15-48-43.png"></p><h2 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//子矩阵的和</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> a[N][N],s[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m ;j ++)<br>            s[i][j] = s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] -s[i <span class="hljs-number">-1</span>][j - <span class="hljs-number">1</span>] + a[i][j];<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,x2,y1,y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x1 - <span class="hljs-number">1</span>][y2] - s[x2][y1 - <span class="hljs-number">1</span>] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><p><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-24-16-06-11.png"></p><h2 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h2><p><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-24-15-58-47.png"><br><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-24-16-01-30.png"></p><h2 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 一维差分</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) a[i] = a[i - <span class="hljs-number">1</span>] + b[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="差分矩阵"><a href="#差分矩阵" class="headerlink" title="差分矩阵"></a>差分矩阵</h1><p><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-24-16-17-51.png"></p><h2 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h2><p><img src="/2023/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B9%A0%E9%A2%98%E8%AF%BE/2023-04-24-16-43-13.png"></p><h2 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> a[N][N],b[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    b[x1][y1] += c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>            <span class="hljs-built_in">insert</span>(i,j,i,j,a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);<br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++)&#123;<br>            a[i][j] = a[i - <span class="hljs-number">1</span>][j] + a[i][j - <span class="hljs-number">1</span>] - a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + b[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>双指针算法</title>
    <link href="/2023/04/22/Pointer/"/>
    <url>/2023/04/22/Pointer/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2023/04/22/Prefix/"/>
    <url>/2023/04/22/Prefix/</url>
    
    <content type="html"><![CDATA[<h1 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><font color = e02b70 size = 4>1.数组从a1，a2...a存储，前缀和的定义为S<sub>i</sub>=a<sub>1</sub>+a<sub>2</sub>+...+a<sub>i</sub>\2.求S<sub>i</sub>\设置S<sub>0</sub> = 0.通过循环，S<sub>i</sub> = S<sub>i-1</sub>+a<sub>i</sub>，即可求出每个S<sub>i</sub>的值3.求区间[l,r]的值x\利用x = S<sub>i</sub>-S<sub>i-1</sub>，即可求出答案。</font><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> +<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> q[N],S[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    S[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) S[i] = S[i<span class="hljs-number">-1</span>] + q[i];            <span class="hljs-comment">//前缀和的初始化</span><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,S[r] - S[l - <span class="hljs-number">1</span>]);                   <span class="hljs-comment">//区间和的计算</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><font color = e02b70 size = 4>1.数组存储在二位数组中 前缀和为S<sub>i</sub><sub>j</sub>，即包含在这个面积里面数的总和\2.求S<sub>i</sub><sub>j</sub>\计算公式S<sub>i</sub><sub>j</sub> = S<sub>i-1</sub><sub>j</sub> + S<sub>i</sub><sub>j-1</sub> + a<sub>i</sub><sub>j</sub>;初始化S[0][0] = 0,通过2层for循环即可求出S[i][j]的值。3.求子矩阵(x1,y1)到(x2,y2)的值x\x = S[x2][y2] - S[x1 - 1][y2]-S[x2][y1 - 1] + S[x1 - 1][y1 - 1]</font><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> a[N][N],S[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++)&#123;<br>            S[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            S[i][j] = S[i - <span class="hljs-number">1</span>][j] + S[i][j - <span class="hljs-number">1</span>] + a[i][j];          <span class="hljs-comment">//求前缀和</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,S[x2][y2]-S[x1 - <span class="hljs-number">1</span>][y2]-S[x2][y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]);   <span class="hljs-comment">//算子矩阵的和</span><br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一维差分-前缀和的逆运算"><a href="#一维差分-前缀和的逆运算" class="headerlink" title="一维差分(前缀和的逆运算)"></a>一维差分(前缀和的逆运算)</h1><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><font color = e02b70 size = 4>1.数组a[1],a[2]...a[n]，构造数组b[1],b[2]...b[n]使得a[i] = b[1] + b[2] + ... +b[i]此时a为b的前缀和，b为a的差分。<p>2.要让a[l]到a[r]中的每个数都+c也就是a[l] + c,a[l + 1] + c,…,a[r] + c<br>3.那么当b[l] + c时，a[l]至a[r]都会+c，并且a[r+1]到a[n]都会+c。<br>为了使a[r+1]到a[n]不能+c，则令b[r + 1] - c,即可做到。<br>※数据初始化时，令数组a与数组b中的元素都是0，然后再利用上面的性质，也就是数组b在[i,i]中插入要输入的数值a[i]，这样就完成了数组b的初始化过程。所以要设一个insert插入函数，在[l，r]中插入数据c，也就是b[l] +&#x3D; c,b[r + 1] -&#x3D; c。</font></p><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//一维差分</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> +<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) <span class="hljs-built_in">insert</span>(i,i,a[i]);        <span class="hljs-comment">//相当于在初始化数组</span><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) b[i] += b[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>,b[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><font color = e02b70 size = 4>1.最开始时就假设了数组a与数组b中的元素都为0，也就是满足了上述数组a与数组b的关系<p>2.然后为了改变数组a中的值也就是改变数组b的值，也就是用插入函数改变b数组元素的值，最后求b数组的前缀和也就是求出了a数组。</p><h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><p>1.与一维差分相似，初始时数组a与数组b中的元素值全为0，即构造出了符合数组a与数组b关系的数组<br>2.书写更新b数组的inert()函数,假设在[x1,y1][x2,y2]的子矩阵中的每个元素都+c<br>则更新的函数insert()函数为:<br>b[x1][y1] +&#x3D;c<br>b[x2 + 1][y1] -&#x3D; c<br>b[x1][y2 + 1] -&#x3D; c<br>b[x2 + 1][y2 + 1] +&#x3D; c<br>3.然后就是接收a数组元素的值，然后根据a数组改变b数组的值，利用insert()函数改变<br>4.最后求出b数组的前缀和也就是要求的答案了.<br></font></p><h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> b[N][N];<br><span class="hljs-type">int</span> n,m,p;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    b[x1][y1] += c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;p);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++)&#123;<br>            <span class="hljs-built_in">insert</span>(i,j,i,j,a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);<br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++)&#123;<br>            b[i][j] += b[i - <span class="hljs-number">1</span>][j] + b[i][j - <span class="hljs-number">1</span>] -b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><font color = e02b70 size = 4>※差分不需要考虑如何去构造函数，因为在最初就假设了数组a与数组b中的元素值全为0，也就符合了b是a的差分，而a是b的前缀和<p>※所以最终就是要求更新函数,也就是inert()函数！！！<br></font></p>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2023/04/20/Highprecision/"/>
    <url>/2023/04/20/Highprecision/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度（加、减、乘、除）"><a href="#高精度（加、减、乘、除）" class="headerlink" title="高精度（加、减、乘、除）"></a>高精度（加、减、乘、除）</h1><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>1.将高精度数用字符串表示string a，b，再用vector用数组表示vector<int> A,B，再调用push_back方法逆序存储，存储由低位向高位存储，这样进位时方便存储，即原始数为”123456”,则存储在数组中的值为[6,5,4,3,2,1].<br>2.设置进位t 本位的值等于(t + A[i] + B[i])%10<br>然后传给下一位的进位为 t &#x3D; (t + A[i] + B[i])&#x2F;10<br>3.如果处理完 最后进位t存在的话，则将数组最后以为置1\</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//C = A + B  大整数加法</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;          <span class="hljs-comment">//进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>();i ++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i];<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];             <span class="hljs-comment">//t = t + a[i] + b[i]</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin &gt;&gt; a &gt;&gt; b;  <span class="hljs-comment">//a = &quot;123456&quot;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//A = [6,5,4,3,2,1,]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">add</span>(A,B);                  <span class="hljs-comment">//自动返回对应的类型也就是vector&lt;int&gt;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;          <span class="hljs-comment">//进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>();i ++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i];<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];             <span class="hljs-comment">//t = t + a[i] + b[i]</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>需先判断A与B的大小，因为如果A比B小的话，相减为负数，则应转换为-(B-A),设置cmp()函数，进行两个数之间的大小比较\</li><li>设置来自低位的借位t，先进行t &#x3D; A[i] - t(每次都要减去来自上一位的借位),判断此时B[i]是否有数，若有的话则，t &#x3D; t - b[i]；此时本位的值为(t + 10) % 10; 如果此时t &lt; 0,则说明要向上以为借1，则此时令t &#x3D; 1；否则的话t &#x3D; 0，重复上述操作，直到遍历完数组A中所有的数\</li><li>得到的结果可能存在高位有0的前导0现象。要做的处理就是将高位为0的数全部弹出，最多只保留1位位0.\</li></ol><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//C = A - B  大整数减法</span><br><span class="hljs-comment">//判断是否有 A&gt;-=B</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span> ;i--)<br>        <span class="hljs-keyword">if</span>(A[i] != B[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,t = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>();i ++)&#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];             <span class="hljs-comment">//t = t + a[i] + b[i]</span><br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>)  t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">//去掉前导0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin &gt;&gt; a &gt;&gt; b;  <span class="hljs-comment">//a = &quot;123456&quot;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//A = [6,5,4,3,2,1,]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))&#123;<br>        <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">sub</span>(A,B);<span class="hljs-comment">//自动返回对应的类型也就是vector&lt;int&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">sub</span>(B,A);<span class="hljs-comment">//自动返回对应的类型也就是vector&lt;int&gt;</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//C = A - B  大整数减法</span><br><span class="hljs-comment">//判断是否有 A&gt;-=B</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span> ;i--)<br>        <span class="hljs-keyword">if</span>(A[i] != B[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,t = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>();i ++)&#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];             <span class="hljs-comment">//t = t + a[i] + b[i]</span><br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>)  t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">//去掉前导0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>算法的主要思想就是将A[i]中每位数都与b相乘，判断其余数（就是C[i]）,而商就是进位，多次循环即可求出结果\</li><li>设置进位t，如果此时A[i]中还有数的话 则t &#x3D; t + A[i] * b,C[i] 就等于 t % 10，产生的下一位进t &#x3D; t &#x2F; 10；重复上诉操作，循环的条件是A[i]没有遍历完，或者t还存在不为0\</li></ol><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//C = A * b  大整数乘法</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>() || t;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt;=<span class="hljs-number">0</span>;i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板代码-1"><a href="#模板代码-1" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//C = A * b  大整数乘法</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>() || t;i ++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>除法与前面三种算法不同，除法是从最高位开始进行计算的，所以在循环的条件i是从A.size() - 1开始。\</li><li>r为余数，进入循环时r &#x3D; r*10 +A[i],则此时的商为r &#x2F; b也就是C,则此时的余数为r &#x3D; r % b.循环上述操作直到遍历完A[]中所有的数。\</li><li>因为此时C[]中的数是由高位到地位的，所以要调用reverse()方法，将其倒置，以保证其输出方式与前面三种算法相同\</li><li>同时该算法也存在前导0的问题，与前面算法的处理相同。\</li></ol><h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// A / b 商是c，余数是r</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)</span></span>&#123;           <span class="hljs-comment">//r是引用</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;          <span class="hljs-comment">//商</span><br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --)&#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt;=<span class="hljs-number">0</span>;i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">div</span>(A, b, r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; r &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板代码-2"><a href="#模板代码-2" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A / b 商是c，余数是r</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)</span></span>&#123;           <span class="hljs-comment">//r是引用</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;          <span class="hljs-comment">//商</span><br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i --)&#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二章JSP语法</title>
    <link href="/2023/04/20/2-Jsp/"/>
    <url>/2023/04/20/2-Jsp/</url>
    
    <content type="html"><![CDATA[<h1 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a><font color = pink size = 8>JSP语法</font></h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a><font color = pink size = 7>主要内容</font></h2><p> <font color = orange size = 6>一：JSP页面的基本结构<br>二：声明变量和定义方法<br>三：Java程序片<br> 四：Java表达式<br>五：JSP中的注释<br>六：JSP指令标记<br>七：JSP动作标记</font></p><h3 id="一：JSP页面的基本结构"><a href="#一：JSP页面的基本结构" class="headerlink" title="一：JSP页面的基本结构"></a><font color = 3fccca size = 5>一：JSP页面的基本结构</font></h3><h4 id="1-1一个JSP页面可由5中元素组合而成："><a href="#1-1一个JSP页面可由5中元素组合而成：" class="headerlink" title="1.1一个JSP页面可由5中元素组合而成："></a><font color = 81cc3f size = 4>1.1一个JSP页面可由5中元素组合而成：</font></h4><p>①普通的HTML标记和JavaScript标记<br>②JSP标记，如指令标记、动作标记<br>③变量和方法的声明<br>④Java程序片<br>⑤Java表达式<br><strong>1.2原理</strong><br>①一个JSP页面被第一次请求执行时，Tomcat服务器首先将JSP页面文件转译成一个Java文件，再将这个Java文件编译生成字节码文件，然后通过执行字节码文件响应用户的请求。<br>②当多个用户请求一个JSP页面时，Tomcat服务器为每个用户启动一个线程，该线程负责执行常驻内存的字节码文件来响应相应用户的请求。这些线程由Tomcat服务器来管理，将CPU的使用权在各个线程之间快速切换，以保证每个线程都有机会执行字节码文件。</p><h3 id="二：声明变量和定义方法"><a href="#二：声明变量和定义方法" class="headerlink" title="二：声明变量和定义方法"></a><font color = 3fccca size = 5><strong>二：声明变量和定义方法</strong></font></h3><h4 id="2-1声明变量"><a href="#2-1声明变量" class="headerlink" title="2.1声明变量 "></a><font color = 81cc3f size = 4>2.1声明变量 </font></h4><p>①&lt;%! ….%&gt; **(&lt;%! 之间不能有空格)**  <br>在&lt;%!和%&gt;标记符号之间声明变量，定义方法以及定义类。&lt;%!和%&gt;标记符号的内容习惯上放在JSP 页面指令之后，&lt;HTML&gt;之前，也可以写在&lt;HTML&gt;与&lt;&#x2F;HTML&gt;之间。<br>&lt;%!和%&gt;之间声明的变量在<font color=red><strong>整个JSP页面内都有效</strong></font>，与标记符在JSP页面中所在的书写位置无关，但习惯上把&lt;%!、%&gt; 标记符写在JSP页面的前面。</p><h4 id="2-2定义方法"><a href="#2-2定义方法" class="headerlink" title="2.2定义方法 "></a><font color = 81cc3f size = 4>2.2定义方法 </font></h4><p>对于在“&lt;%!”和“%&gt;”标记符号之间定义方法，可以在Java程序片中调用该方法。<font color = ef3498>方法内声明的变量只在该方法内有效，当方法被调用时，方法内声明的变量被分配内存，方法被调用完毕即可释放这些变量所占的内存。</font>可以在“&lt;%!”和“%&gt;”标记符号之间<font color=red><strong>定义类</strong></font>，可以在Java程序片中使用该类创建对象。<br><strong>注意</strong> <br><font color = ef3498><br>1.Tomcat服务器将JSP页面转译成Java 文件时，将“&lt;%!”、“%&gt;” 标记符之间声明的变量作为类的成员变量，这些变量占有的内存空间直到Tomcat服务器关闭才释放<br>2.当多个用户请求一个JSP页面时，Tomcat服务器为每个用户启动一个线程，这些线程由Tomcat服务器来管理，这些线程共享JSP页面的成员变量，因此任何一个用户对JSP页面成员变量操作的结果，都会影响到其他用户。</font><br><font color = 41ec52 size = 4>代码举例</font></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ <span class="hljs-type">page</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;text/html&quot;</span>%&gt;<br>&lt;%@ page pageEncoding=<span class="hljs-string">&quot;utf-8&quot;</span>%&gt;<br>&lt;HTML&gt;&lt;body bgcolor=#ffccff&gt;<br>&lt;p style=<span class="hljs-string">&quot;font-family:宋体,font-size:36;color:blue&quot;</span>&gt;<br>&lt;%! <br>    <span class="hljs-type">double</span> <span class="hljs-title function_">multi</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> y)</span>&#123;  <span class="hljs-comment">//定义方法</span><br>        <span class="hljs-keyword">return</span> x*y;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>&#123;<br>        <span class="hljs-type">double</span> r;<br>        <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span>&#123;             <span class="hljs-comment">//定义类</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span>*r*r;<br>        &#125;<br>    &#125;<br>%&gt; <br>&lt;%                                   <span class="hljs-comment">//Java程序片</span><br>    <span class="hljs-type">double</span> x=<span class="hljs-number">8.0</span>;<br>    <span class="hljs-type">double</span> y=<span class="hljs-number">12.0</span>;<br>    out.print(multi(x,y));           <span class="hljs-comment">//调用方法</span><br>    Circle circle=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br>    circle.r=<span class="hljs-number">3.0</span>;                    <br>    out.print(circle.getArea());     <span class="hljs-comment">//调用类</span><br>%&gt;<br>&lt;/p&gt;&lt;/body&gt;&lt;/HTML&gt;<br></code></pre></td></tr></table></figure><h3 id="三：Java程序片"><a href="#三：Java程序片" class="headerlink" title="三：Java程序片"></a><font color = 3fccca size = 5><strong>三：Java程序片</strong></font></h3><h4 id="3-1插入程序片"><a href="#3-1插入程序片" class="headerlink" title="3.1插入程序片"></a><font color = 81cc3f size = 4>3.1插入程序片</font></h4><p>可以在&lt;%和%&gt;之间插入Java 程序片。</p><h4 id="3-2局部变量"><a href="#3-2局部变量" class="headerlink" title="3.2局部变量 "></a><font color = 81cc3f size = 4>3.2局部变量 </font></h4><p>一个JSP页面可以有许多程序片，这些程序片将被Tomcat服务器按顺序执行。在程序片中声明的变量称作JSP页面的局部变量。局部变量的有效范围与其声明的位置有关，即局部变量在JSP页面后继的所有程序片以及表达式部分内都有效。</p><h4 id="3-3处理程序片"><a href="#3-3处理程序片" class="headerlink" title="3.3处理程序片 "></a><font color = 81cc3f size = 4>3.3处理程序片 </font></h4><p>当多个用户请求一个JSP页面时，Tomcat服务器为每个用户启动一个线程，该线程负责执行字节码文件响应用户的请求。Tomcat服务器使用多线程来处理程序片.</p><h4 id="3-4操作JSP页面的成员变量"><a href="#3-4操作JSP页面的成员变量" class="headerlink" title="3.4操作JSP页面的成员变量 "></a><font color = 81cc3f size = 4>3.4操作JSP页面的成员变量 </font></h4><p>Java 程序片中操作的成员变量是各个线程（用户）共享的变量，任何一个线程对JSP页面成员变量操作的结果，都会影响到其他线程。</p><h4 id="3-5操调用JSP页面的方法"><a href="#3-5操调用JSP页面的方法" class="headerlink" title="3.5操调用JSP页面的方法 "></a><font color = 81cc3f size = 4>3.5操调用JSP页面的方法 </font></h4><p>Java 程序片中可以出现方法调用语句，所调用的方法必须是JSP页面曾定义的方法。</p><h4 id="3-6操作局部变量"><a href="#3-6操作局部变量" class="headerlink" title="3.6操作局部变量 "></a><font color = 81cc3f size = 4>3.6操作局部变量 </font></h4><p>当一个线程享用CPU资源时，Tomcat服务器让该线程执行Java程序片，这时，Java程序片中的局部变量被分配内存空间，当轮到另一个线程享用CPU资源时，Tomcat服务器让该线程再次执行Java程序片，那么，Java程序片中的局部变量会再次分配内存空间。也就是说Java程序片已经被执行了两次，分别运行在不同的线程中，即运行在不同的时间片内。运行在不同线程中的Java程序片的局部变量互不干扰，即一个用户改变Java程序片中的局部变量的值不会影响其他用户的Java程序片中的局部变量。当一个线程将Java程序片执行完毕，运行在该线程中的Java程序片的局部变量释放所占的内存。</p><h3 id="四：Java表达式"><a href="#四：Java表达式" class="headerlink" title="四：Java表达式"></a><font color = 3fccca size = 5><strong>四：Java表达式</strong></font></h3><h4 id="4-1表达式"><a href="#4-1表达式" class="headerlink" title="4.1表达式"></a><font color = 81cc3f size = 4>4.1表达式</font></h4><p>可以在&lt;%&#x3D;和%&gt;之间插入一个可求值的表达式（注意：不可插入语句，&lt;%&#x3D;是一个完整的符号，“&lt;%”和“&#x3D;”之间不要有空格）。表达式的值由服务器负责计算，并将计算结果用字符串形式发送到用户端显示。<br>Java表达式可以写在&lt;HTML&gt;之前，也可以写在&lt;HTML&gt;和&lt;&#x2F;HTML&gt;之间或&lt;&#x2F;HTML&gt;之后。</p><h4 id="4-2注意事项"><a href="#4-2注意事项" class="headerlink" title=" 4.2注意事项"></a><font color = 81cc3f size = 4> 4.2注意事项</font></h4><p>在JSP页面中，表达式的值被表示成一个字符串的形式，即Tomcat服务器将表达式的结果转换成字符串，然后发送给用户的浏览器。因此，在编写JSP页面时，要把Java表达式按普通的文本来使用。</p><h3 id="五：JSP中的注释"><a href="#五：JSP中的注释" class="headerlink" title="五：JSP中的注释"></a><font color = 3fccca size = 5><strong>五：JSP中的注释</strong></font></h3><h4 id="5-1HTML注释"><a href="#5-1HTML注释" class="headerlink" title="5.1HTML注释"></a><font color = 81cc3f size = 4>5.1HTML注释</font></h4><p>&lt;!–    注释内容     –&gt;<br>JSP引擎把HTML注释交给用户，因此用户通过浏览器查看JSP页面的源文件时，能够看到HTML注释。</p><h4 id="5-2JSP注释"><a href="#5-2JSP注释" class="headerlink" title="5.2JSP注释"></a><font color = 81cc3f size = 4>5.2JSP注释</font></h4><p>在标记符号“&lt;%–”和“–%&gt;”之间加入注释内容：<br>&lt;%–  注释内容  –%&gt;  <br>Tomcat服务器忽略JSP注释，即在编译JSP页面时忽略JSP注释。</p><h3 id="六：JSP指令标记"><a href="#六：JSP指令标记" class="headerlink" title="六：JSP指令标记"></a><font color = 3fccca size = 5><strong>六：JSP指令标记</strong></font></h3><h4 id="6-1page指令标记"><a href="#6-1page指令标记" class="headerlink" title="6.1page指令标记"></a><font color = 81cc3f size = 4>6.1page指令标记</font></h4><p>page 指令用来定义整个JSP页面的一些属性和这些属性的值。<br>&lt;%@ page   属性1&#x3D;”属性1的值”  %&gt;<br>&lt;%@ page   属性2&#x3D;”属性2的值”  %&gt;<br>… …<br>&lt;%@ page   属性n&#x3D;”属性n的值”  %&gt;<br>也可以用一个page指令指定多个属性的值，如：<br>&lt;%@ page   属性1&#x3D;”属性1的值”  属性2&#x3D; “属性2的值”  ……%&gt;<br>page 指令标记可以指定属性：contentType、import、language、session、buffer、auotFlush 、isThreadSafe、pageEncoding 、inform的值</p><h4 id="6-2contentType属性"><a href="#6-2contentType属性" class="headerlink" title="6.2contentType属性"></a><font color = 81cc3f size = 4>6.2contentType属性</h4></font> JSP页面设置响应的MIME（Multipurpose Internet Mail Extention）类型，即设置contentType 属性的值。contentType属性值确定JSP页面响应的MIME类型。属性值的一般形式是： "MIME类型"<p>例如：&lt;%@ page contentType&#x3D;”text&#x2F;html “ %&gt;<br>浏览器启用HTML解析器来解析执行所接收到的信息。<br>如果希望用户的浏览器启用本地的MS-Word应用程序来解析执行收到的信息，就可以如下设置contentType属性的值：&lt;%@ page contentType&#x3D;”application&#x2F;msword” %&gt;</p><h4 id="6-3pageEncoding属性"><a href="#6-3pageEncoding属性" class="headerlink" title="6.3pageEncoding属性"></a><font color = 81cc3f size = 4>6.3pageEncoding属性</h4></font> 只能为pageEncoding指定一个值，不允许两次使用page指令给pageEncoding属性指定不同的或相同的属性值。\例如：<%@ page pageEncoding = "utf-8" %>那么保存JSP页面应当将“编码”选择为“utf-8”.<h4 id="6-4language属性"><a href="#6-4language属性" class="headerlink" title="6.4language属性"></a><font color = 81cc3f size = 4>6.4language属性</font></h4><p>language属性定义JSP页面使用的脚本语言，该属性的值目前只能取”java”。<br>为language属性指定值的格式是：<br>&lt;%@ page  language&#x3D;”java” %&gt;<br>language属性的默认值是”java”，即如果在JSP页面中没有使用page指令指定该属性的值的，那么，JSP页面默认有如下的page指令：&lt;%@ page  language&#x3D;”java” %&gt;</p><h4 id="6-5import-属性"><a href="#6-5import-属性" class="headerlink" title="6.5import 属性"></a><font color = 81cc3f size = 4>6.5import 属性</font></h4><p>该属性的作用是为JSP页面引入Java运行环境提供的包中的类。<br>例如：<br>&lt;%@ page  import&#x3D;”java.io.<em>“, “java.time.LocalDate” %&gt;<br>&lt;%@ page  import&#x3D;”java.util.*” %&gt;<br>&lt;%@ page  import&#x3D;”java.io.*”  %&gt;<br>JSP页面默认import属性已经有如下的值：<br>“ java.lang.</em>“、 “javax.servlet.<em>“、”javax.servlet.jsp.</em>“、”javax.servlet.http.*”。</p><h4 id="6-6session属性"><a href="#6-6session属性" class="headerlink" title="6.6session属性"></a><font color = 81cc3f size = 4>6.6session属性</font></h4><p>session 属性用于设置是否需要使用内置的session对象。session的属性值可以是true或false。session属性默认的属性值是true。</p><h4 id="6-7buffer属性"><a href="#6-7buffer属性" class="headerlink" title="6.7buffer属性"></a><font color = 81cc3f size = 4>6.7buffer属性</font></h4><p>内置输出流对象out负责将服务器的某些信息或运行结果发送到用户端显示。buffer属性用来指定out设置的缓冲区的大小或不使用缓冲区。例如：<br>&lt;%@ page buffer&#x3D; “24kb” %&gt;<br>buffer属性的默认值是8kb 。</p><h4 id="6-8autoFlush属性"><a href="#6-8autoFlush属性" class="headerlink" title="6.8autoFlush属性"></a><font color = 81cc3f size = 4>6.8autoFlush属性</font></h4><p>autoFlush可以取值true或false。autoFlush属性的默认值是true。</p><h4 id="6-9isThreadSafe-属性"><a href="#6-9isThreadSafe-属性" class="headerlink" title="6.9isThreadSafe 属性"></a><font color = 81cc3f size = 4>6.9isThreadSafe 属性</h4><p></font> <br>isThreadSafe的属性值可取true或false。<br>isThreadSafe属性值为true时，CPU的使用权在各个线程间快速切换.<br>isThreadSafe属性值设置成false时，该JSP页面同一时刻只能响应一个用户的请求，其他用户须排队等待。也就是说，CUP要保证一个线程将JSP页面执行完毕才会把CPU使用权切换给其他线程</p><h4 id="6-10info-属性"><a href="#6-10info-属性" class="headerlink" title="6.10info 属性"></a><font color = 81cc3f size = 4>6.10info 属性</font></h4><p>info属性的属性值是一个字符串，其目的是为JSP页面准备一个常用但可能要经常修改的字符串。例如，&lt;%@ page info&#x3D; “we are students” %&gt;可以在JSP页面中使用方法：getServletInfo();<br>获取info属性的属性值。</p><h4 id="6-11include-指令标记"><a href="#6-11include-指令标记" class="headerlink" title="6.11include 指令标记 "></a><font color = 81cc3f size = 4>6.11include 指令标记 </font></h4><p>如果需要在JSP页面内某处整体嵌入一个文件，就可以考虑使用include指令标记，其语法格式如下：<br>&lt;%@ include file&#x3D; “文件的URL “ %&gt;<br>■ 嵌入的文件的编码必须和当前JSP页面一致，比如二者都是utf-8编码。<br>■ 所谓静态嵌入，就是当前JSP页面和嵌入的文件合并成一个新的JSP页面，然后Tomcat服务器再将这个新的JSP页面转译成Java文件。因此，嵌入文件后，必须保证新合并成的JSP页面符合JSP语法规则，即能够成为一个JSP页面文件。<br>■include指令可以实现代码的复用。比如，每个JSP页面上都可能都需要一个导航条，以便用户在各个JSP页面之间方便地切换，那么每个JSP页面都可以使用include指令在页面的适当位置整体嵌入一个相同的文件。<br>■允许被嵌入的文件使用page指令指定contentType属性的值，但指定的值要与嵌入该文件的JSP页面中的page指令指定的contentType属性的值相同。</p><p><font color = 41ec52 size = 4>代码示例</font></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsp">example2_10_a.jsp<br>&lt;HTML&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html&quot;</span>%&gt;<br>&lt;%@ page pageEncoding=<span class="hljs-string">&quot;utf-8&quot;</span>%&gt;<br>&lt;%@ include file=<span class="hljs-string">&quot;myfile/ok.txt&quot;</span>%&gt;<span class="hljs-comment">//嵌入一个静态页面</span><br>&lt;h1&gt;这里是北京&lt;/h1&gt;<br>&lt;/HTML&gt;<br><br>example2_10_b.jsp<br>&lt;HTML&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html&quot;</span>%&gt;<br>&lt;%@ page pageEncoding=<span class="hljs-string">&quot;utf-8&quot;</span>%&gt;<br>&lt;%@ include file=<span class="hljs-string">&quot;myfile/ok.txt&quot;</span>%&gt; <span class="hljs-comment">//嵌入一个静态页面</span><br>&lt;h1&gt;这里是南京&lt;/h1&gt;<br>&lt;/HTML&gt;<br><br>ok.txt<br> <br>&lt;%@ <span class="hljs-type">page</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;text/html&quot;</span>%&gt;<br>&lt;center&gt;<br>&lt;A href=<span class="hljs-string">&quot;example2_10_a.jsp&quot;</span>&gt;北京&lt;/A&gt; <span class="hljs-comment">//超链接，点击可以跳转到href属性的值的页面</span><br>&lt;A href=<span class="hljs-string">&quot;example2_10_b.jsp&quot;</span>&gt;南京&lt;/A&gt;<br></code></pre></td></tr></table></figure><h3 id="七：JSP动作标记"><a href="#七：JSP动作标记" class="headerlink" title="七：JSP动作标记"></a><font color = 3fccca size = 5><strong>七：JSP动作标记</strong></font></h3><h4 id="7-1-include动作标记"><a href="#7-1-include动作标记" class="headerlink" title="7.1 include动作标记"></a><font color = 81cc3f size = 4>7.1 include动作标记</font></h4><p>include 动作标记语法格式为：<br>&lt;jsp:include page&#x3D; “文件的URL” &#x2F;&gt;<br>或<br>&lt;jsp:include page&#x3D; “文件的URL” &gt;<br>   param子标记<br></jsp:include><br>include动作标记告诉JSP页面动态包含一个文件，即JSP页面运行时才将文件加入。与静态嵌入文件的include指令标记不同，当Tomcat服务器根据JSP页面产生成Java文件时，不把JSP页面中动作指令include所包含的文件与原JSP页面合并为一个新的JSP页面，而是告诉Java解释器，这个文件在JSP运行（Java文件的字节码文件被加载执行）时才包含进来。如果包含的文件是普通的文本文件，就将文件的内容发送到用户端，由用户端的浏览器负责显示；如果包含的文件是JSP文件，Tomcat服务器就执行这个文件，然后将执行的结果发送到用户端，并由用户端的浏览器负责显示这些结果。</p><h4 id="7-2-param动作标记"><a href="#7-2-param动作标记" class="headerlink" title="7.2 param动作标记"></a><font color = 81cc3f size = 4>7.2 param动作标记</font></h4><p>param标记以“名字—值”对的形式为其他标记提供附加信息。<br>&lt;jsp:param  name&#x3D; “参数”  value&#x3D; “ 参数的值” &#x2F;&gt;</p><h4 id="7-3-forward-动作标记"><a href="#7-3-forward-动作标记" class="headerlink" title="7.3 forward 动作标记"></a><font color = 81cc3f size = 4>7.3 forward 动作标记</font></h4><p>&lt;jsp:forward page&#x3D;”要转向的页面” &#x2F;&gt;<br>或<br>&lt;jsp:forward page&#x3D;”要转向的页面” &gt;<br>   param子标记<br></jsp:forward><br>指令的作用是：从该指令处停止当前页面的执行，而转向执行page属性指定的JSP页面。需要注意的是，当前页面使用forward动作标记转向后，尽管用户看到了转向后的页面的效果，但浏览器地址栏中显示的仍然是转向前的JSP页面的URL地址，因此，如果刷新浏览器的显示，将再次执行当前浏览器地址栏中显示的JSP页面。</p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2023/04/19/BinarySearch/"/>
    <url>/2023/04/19/BinarySearch/</url>
    
    <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><font size = 3>※二分的本质并不是单调性 有单调性一定可以二分 用二分的不一定有单调性<br>※二分的本质是找<font color = pink>边界点</font> 每次二分时选择答案所在区间 当区间长度为1时 得出答案<br>※若有某种性质使得一部分满足 另一部分不满足,二分可以用来寻找这个性质边界(两个边界对应两个模板)<br>※<font color = pink>整数二分需要考虑边界问题，浮点二分不需要考虑边界问题。</font><br>**当l &#x3D; mid 时 mid &#x3D; l + r + 1 &gt;&gt; 1;**<br><strong>当r &#x3D; mid 时 mid &#x3D; l + r &gt;&gt; 1;</strong></font></p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(mid)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125;;<span class="hljs-comment">// 检查mid是否满足某种性质</span><br><span class="hljs-comment">//右半区间成立 二分右边的分界点</span><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">//左半区间成立 二分左边的分界点</span><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;       <span class="hljs-comment">//向上取整</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp">### 整数二分<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>,r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid] &gt;= x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(q[l] != x) cout &lt;&lt; <span class="hljs-string">&quot;-1 -1&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout &lt;&lt; l &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(q[mid] &lt;= x) l =mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            cout &lt;&lt; l &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>### 浮点二分（求某个浮点数的平方根）<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-type">double</span> l = <span class="hljs-number">0</span>,r = x;<br>    <span class="hljs-keyword">while</span>(r - l &gt; <span class="hljs-number">1e-8</span>)&#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color = 3fccca size = 4><strong>算法书写过程</strong></font><br><font color = f18ed3 size = 3><br>★先写mid &#x3D; l + r &gt;&gt; 1;<br>★在确定check函数；<br>★最后根据所写出的l与r的值确定mid是否要加1，防止边界问题<br></font><br><font color = 3fccca size = 4>分析边界问题</font><br><font color = e45a7c size = 3>▲若当l &#x3D; mid 时， 没有取 mid &#x3D; l + r + 1 &gt;&gt;1 向上取整，而是取mid &#x3D; l + r &gt;&gt; 1 向下取整<br>当l &#x3D; r - 1时，mid &#x3D; l，若此时check函数返回值为true，则此时跟新的区间为[l,r];所以此次循环并没有改变区间，则下次循环也不会改变区间，也就是进入了死循环<br>▲当mid取了 mid &#x3D; l + r + 1 &gt;&gt; 1时，则mid &#x3D; r，则此时更新的区间为[r,r],就会停止循环了，不会进入死循环了.</font></p>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2023/04/19/merge-sort/"/>
    <url>/2023/04/19/merge-sort/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>分治</strong><br>1.确定分界点—-mid &#x3D; (l + r) &#x2F; 2  <br>2.递归排序left、right<br>3.归并–合二为一 </p><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> +<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> temp[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q,l,mid),<span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>,i = l,j = mid +<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) temp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> temp[k++] = q[j++];<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) temp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) temp[k++] = q[j++];<br>    <span class="hljs-keyword">for</span>(i = l,j = <span class="hljs-number">0</span>;i &lt;= r;i++,j++)<br>    q[i] = temp[j];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    &#125;<br>    <span class="hljs-built_in">merge_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>,q[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a><strong>代码模板</strong>：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r)<br>    <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q,l,mid),<span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>,i = l,j = mid + <span class="hljs-number">1</span>;        <span class="hljs-comment">//i指向左边的起点，j指向右边的起点</span><br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j&lt;= r) <br>        <span class="hljs-keyword">if</span>(q[i] &lt; q[j]) temp[k++] = q[i];<br>        <span class="hljs-keyword">else</span> temp[k++] = q[j];<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) temp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) temp[k++] = q[j++];<br>    <span class="hljs-keyword">for</span>(i = l, j = <span class="hljs-number">0</span>;i &lt;= r;i++,j++)<br>    q[i] = temp[j];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>算法图解</strong><br><img src="/2023/04/19/merge-sort/2023-04-19-23-19-36.png"></p><h2 id="归并排序算法的特点"><a href="#归并排序算法的特点" class="headerlink" title="归并排序算法的特点"></a>归并排序算法的特点</h2><p><strong>1.时间复杂度</strong>  <br>归并排序算法每次将序列折半分组，共需要logn轮，因此归并排序算法的时间复杂度是O(nlogn)    <br><strong>2.空间复杂度</strong>    \<br>归并排序算法排序过程中需要额外的一个序列去存储排序后的结果，所占空间是n，因此空间复杂度为O(n) <br><strong>3.稳定性</strong>    <br>归并排序算法排序过程中需要额外的一个序列去存储排序后的结果，所占空间是n，因此空间复杂度为O(n)</p>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2023/04/19/quick-sort/"/>
    <url>/2023/04/19/quick-sort/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>分治</strong></p><ol><li>确定分界点：头 、尾 、（头＋尾）&#x2F;2、 随机</li><li>调整区间，使得小于分界点的数全在其左边，大于分界点的数全在右边<ul><li>利用两个指针在数列两头向中间移动，左边的指针在碰到大于等于分界点时停下，右边的指针反之，都停下时交换两数，循环上述过程，直到两指针相交</li></ul></li><li>递归处理左右两端</li></ol><p>题目:<br><a href="https://www.acwing.com/problem/content/787/">快速排序</a></p><p>完整代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//加10防止越界</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;         <span class="hljs-comment">//退出递归的条件</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)           <br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j),<span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a><strong>代码模板</strong>：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>若x取q[l]或者q[r]要考虑边界问题</strong><br>若 递归处用 i-1 和 i ,则x<strong>不可以</strong>取q[l] ,<strong>可以</strong>取q[r]或者q[(l+r+1)&#x2F;2]或者q[l+r+1&gt;&gt;1]等<br>若 递归处用 j 和 j+1 ,则x<strong>不可以</strong>取q[r] ,<strong>可以</strong>取q[l]或者q[(l+r)&#x2F;2]或者q[l+r&gt;&gt;1]等<br>否则可能会出现死循环<br>例如:x取q[l],递归处用i-1和i,排序12,会无限调用递归quick_sort(q,0,1),即无限划分</p><p><strong>快排是不稳定的</strong><br>在排序前，关键字值相等的不同记录，排序后相对位置保持不变的排序方法，称为稳定排序方法（但其实没软用）<br>如何把快排变成稳定的呢—————把快排每个数变成不同的，可把每个数据弄成二元组，双关键字排序</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h3><p><strong>边界问题分析</strong><br>分治算法最怕<code>n分成0和n,或n分成n和0</code>,这会造成<em>无限划分</em><br>若<code>x=q[l]</code>时 最极端情况是<code>i=l,j=l</code> 此时若划分为<code>(l,i-1)</code>和<code>(i,r)</code> 其中<code>(i,r)</code>划分的就是<code>n</code> 这就出现了<em>无限划分</em><br>若<code>x=q[r]</code>时 最极端情况时<code>i=r,j=r</code> 此时若划分为<code>(l,j)</code>和<code>(j+1,r)</code> 其中<code>(l,j)</code>划分的就是<code>n</code> 这就出现了<em>无限划分</em><br>最后是关于<code>q[l+r&gt;&gt;1]</code>和<code>q[l+r+1&gt;&gt;1]</code> 的问题,<br><code>q[l+r+1&gt;&gt;1]</code>是向上取整,因为向上取整时有可能取到q[r],为了避免<em>无限划分</em>,所以递归处划分应该是i-1和i<br><code>q[l+r&gt;&gt;1]</code>是向下取整,因为向下取整时有可能取到q[l],为了避免<em>无限划分</em>,所以递归处划分应该时j和j+1<br><a href="https://www.acwing.com/solution/content/16777/"></a></p><p>最后<br>为什么y总要<code>const int N = 1e6+10;</code> 要加10呢 我也没懂 但参考:<a href="https://www.zhihu.com/question/35047872">知乎</a></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>分治</p><ol><li>确定分界点：mid&#x3D;l+r&gt;&gt;1</li><li>递归排序left，right</li><li>归并————合二为一</li></ol><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
